// This file is generated by rust-protobuf 2.14.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `sentencepiece_model.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_14_0;

#[derive(PartialEq,Clone,Default)]
pub struct TrainerSpec {
    // message fields
    input: ::protobuf::RepeatedField<::std::string::String>,
    input_format: ::protobuf::SingularField<::std::string::String>,
    model_prefix: ::protobuf::SingularField<::std::string::String>,
    model_type: ::std::option::Option<TrainerSpec_ModelType>,
    vocab_size: ::std::option::Option<i32>,
    accept_language: ::protobuf::RepeatedField<::std::string::String>,
    self_test_sample_size: ::std::option::Option<i32>,
    character_coverage: ::std::option::Option<f32>,
    input_sentence_size: ::std::option::Option<i32>,
    shuffle_input_sentence: ::std::option::Option<bool>,
    mining_sentence_size: ::std::option::Option<i32>,
    training_sentence_size: ::std::option::Option<i32>,
    seed_sentencepiece_size: ::std::option::Option<i32>,
    shrinking_factor: ::std::option::Option<f32>,
    max_sentence_length: ::std::option::Option<i32>,
    num_threads: ::std::option::Option<i32>,
    num_sub_iterations: ::std::option::Option<i32>,
    max_sentencepiece_length: ::std::option::Option<i32>,
    split_by_unicode_script: ::std::option::Option<bool>,
    split_by_number: ::std::option::Option<bool>,
    split_by_whitespace: ::std::option::Option<bool>,
    treat_whitespace_as_suffix: ::std::option::Option<bool>,
    split_digits: ::std::option::Option<bool>,
    control_symbols: ::protobuf::RepeatedField<::std::string::String>,
    user_defined_symbols: ::protobuf::RepeatedField<::std::string::String>,
    required_chars: ::protobuf::SingularField<::std::string::String>,
    byte_fallback: ::std::option::Option<bool>,
    vocabulary_output_piece_score: ::std::option::Option<bool>,
    hard_vocab_limit: ::std::option::Option<bool>,
    use_all_vocab: ::std::option::Option<bool>,
    unk_id: ::std::option::Option<i32>,
    bos_id: ::std::option::Option<i32>,
    eos_id: ::std::option::Option<i32>,
    pad_id: ::std::option::Option<i32>,
    unk_piece: ::protobuf::SingularField<::std::string::String>,
    bos_piece: ::protobuf::SingularField<::std::string::String>,
    eos_piece: ::protobuf::SingularField<::std::string::String>,
    pad_piece: ::protobuf::SingularField<::std::string::String>,
    unk_surface: ::protobuf::SingularField<::std::string::String>,
    train_extremely_large_corpus: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrainerSpec {
    fn default() -> &'a TrainerSpec {
        <TrainerSpec as ::protobuf::Message>::default_instance()
    }
}

impl TrainerSpec {
    pub fn new() -> TrainerSpec {
        ::std::default::Default::default()
    }

    // repeated string input = 1;


    pub fn get_input(&self) -> &[::std::string::String] {
        &self.input
    }
    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.input = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.input
    }

    // Take field
    pub fn take_input(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.input, ::protobuf::RepeatedField::new())
    }

    // optional string input_format = 7;


    pub fn get_input_format(&self) -> &str {
        match self.input_format.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_input_format(&mut self) {
        self.input_format.clear();
    }

    pub fn has_input_format(&self) -> bool {
        self.input_format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_format(&mut self, v: ::std::string::String) {
        self.input_format = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_format(&mut self) -> &mut ::std::string::String {
        if self.input_format.is_none() {
            self.input_format.set_default();
        }
        self.input_format.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_format(&mut self) -> ::std::string::String {
        self.input_format.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string model_prefix = 2;


    pub fn get_model_prefix(&self) -> &str {
        match self.model_prefix.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_model_prefix(&mut self) {
        self.model_prefix.clear();
    }

    pub fn has_model_prefix(&self) -> bool {
        self.model_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_prefix(&mut self, v: ::std::string::String) {
        self.model_prefix = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_prefix(&mut self) -> &mut ::std::string::String {
        if self.model_prefix.is_none() {
            self.model_prefix.set_default();
        }
        self.model_prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_model_prefix(&mut self) -> ::std::string::String {
        self.model_prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .sentencepiece.TrainerSpec.ModelType model_type = 3;


    pub fn get_model_type(&self) -> TrainerSpec_ModelType {
        self.model_type.unwrap_or(TrainerSpec_ModelType::UNIGRAM)
    }
    pub fn clear_model_type(&mut self) {
        self.model_type = ::std::option::Option::None;
    }

    pub fn has_model_type(&self) -> bool {
        self.model_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_type(&mut self, v: TrainerSpec_ModelType) {
        self.model_type = ::std::option::Option::Some(v);
    }

    // optional int32 vocab_size = 4;


    pub fn get_vocab_size(&self) -> i32 {
        self.vocab_size.unwrap_or(8000i32)
    }
    pub fn clear_vocab_size(&mut self) {
        self.vocab_size = ::std::option::Option::None;
    }

    pub fn has_vocab_size(&self) -> bool {
        self.vocab_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vocab_size(&mut self, v: i32) {
        self.vocab_size = ::std::option::Option::Some(v);
    }

    // repeated string accept_language = 5;


    pub fn get_accept_language(&self) -> &[::std::string::String] {
        &self.accept_language
    }
    pub fn clear_accept_language(&mut self) {
        self.accept_language.clear();
    }

    // Param is passed by value, moved
    pub fn set_accept_language(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.accept_language = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accept_language(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accept_language
    }

    // Take field
    pub fn take_accept_language(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.accept_language, ::protobuf::RepeatedField::new())
    }

    // optional int32 self_test_sample_size = 6;


    pub fn get_self_test_sample_size(&self) -> i32 {
        self.self_test_sample_size.unwrap_or(0i32)
    }
    pub fn clear_self_test_sample_size(&mut self) {
        self.self_test_sample_size = ::std::option::Option::None;
    }

    pub fn has_self_test_sample_size(&self) -> bool {
        self.self_test_sample_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_self_test_sample_size(&mut self, v: i32) {
        self.self_test_sample_size = ::std::option::Option::Some(v);
    }

    // optional float character_coverage = 10;


    pub fn get_character_coverage(&self) -> f32 {
        self.character_coverage.unwrap_or(0.9995f32)
    }
    pub fn clear_character_coverage(&mut self) {
        self.character_coverage = ::std::option::Option::None;
    }

    pub fn has_character_coverage(&self) -> bool {
        self.character_coverage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_character_coverage(&mut self, v: f32) {
        self.character_coverage = ::std::option::Option::Some(v);
    }

    // optional int32 input_sentence_size = 11;


    pub fn get_input_sentence_size(&self) -> i32 {
        self.input_sentence_size.unwrap_or(0i32)
    }
    pub fn clear_input_sentence_size(&mut self) {
        self.input_sentence_size = ::std::option::Option::None;
    }

    pub fn has_input_sentence_size(&self) -> bool {
        self.input_sentence_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_sentence_size(&mut self, v: i32) {
        self.input_sentence_size = ::std::option::Option::Some(v);
    }

    // optional bool shuffle_input_sentence = 19;


    pub fn get_shuffle_input_sentence(&self) -> bool {
        self.shuffle_input_sentence.unwrap_or(true)
    }
    pub fn clear_shuffle_input_sentence(&mut self) {
        self.shuffle_input_sentence = ::std::option::Option::None;
    }

    pub fn has_shuffle_input_sentence(&self) -> bool {
        self.shuffle_input_sentence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shuffle_input_sentence(&mut self, v: bool) {
        self.shuffle_input_sentence = ::std::option::Option::Some(v);
    }

    // optional int32 mining_sentence_size = 12;


    pub fn get_mining_sentence_size(&self) -> i32 {
        self.mining_sentence_size.unwrap_or(0)
    }
    pub fn clear_mining_sentence_size(&mut self) {
        self.mining_sentence_size = ::std::option::Option::None;
    }

    pub fn has_mining_sentence_size(&self) -> bool {
        self.mining_sentence_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mining_sentence_size(&mut self, v: i32) {
        self.mining_sentence_size = ::std::option::Option::Some(v);
    }

    // optional int32 training_sentence_size = 13;


    pub fn get_training_sentence_size(&self) -> i32 {
        self.training_sentence_size.unwrap_or(0)
    }
    pub fn clear_training_sentence_size(&mut self) {
        self.training_sentence_size = ::std::option::Option::None;
    }

    pub fn has_training_sentence_size(&self) -> bool {
        self.training_sentence_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_training_sentence_size(&mut self, v: i32) {
        self.training_sentence_size = ::std::option::Option::Some(v);
    }

    // optional int32 seed_sentencepiece_size = 14;


    pub fn get_seed_sentencepiece_size(&self) -> i32 {
        self.seed_sentencepiece_size.unwrap_or(1000000i32)
    }
    pub fn clear_seed_sentencepiece_size(&mut self) {
        self.seed_sentencepiece_size = ::std::option::Option::None;
    }

    pub fn has_seed_sentencepiece_size(&self) -> bool {
        self.seed_sentencepiece_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seed_sentencepiece_size(&mut self, v: i32) {
        self.seed_sentencepiece_size = ::std::option::Option::Some(v);
    }

    // optional float shrinking_factor = 15;


    pub fn get_shrinking_factor(&self) -> f32 {
        self.shrinking_factor.unwrap_or(0.75f32)
    }
    pub fn clear_shrinking_factor(&mut self) {
        self.shrinking_factor = ::std::option::Option::None;
    }

    pub fn has_shrinking_factor(&self) -> bool {
        self.shrinking_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shrinking_factor(&mut self, v: f32) {
        self.shrinking_factor = ::std::option::Option::Some(v);
    }

    // optional int32 max_sentence_length = 18;


    pub fn get_max_sentence_length(&self) -> i32 {
        self.max_sentence_length.unwrap_or(4192i32)
    }
    pub fn clear_max_sentence_length(&mut self) {
        self.max_sentence_length = ::std::option::Option::None;
    }

    pub fn has_max_sentence_length(&self) -> bool {
        self.max_sentence_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_sentence_length(&mut self, v: i32) {
        self.max_sentence_length = ::std::option::Option::Some(v);
    }

    // optional int32 num_threads = 16;


    pub fn get_num_threads(&self) -> i32 {
        self.num_threads.unwrap_or(16i32)
    }
    pub fn clear_num_threads(&mut self) {
        self.num_threads = ::std::option::Option::None;
    }

    pub fn has_num_threads(&self) -> bool {
        self.num_threads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_threads(&mut self, v: i32) {
        self.num_threads = ::std::option::Option::Some(v);
    }

    // optional int32 num_sub_iterations = 17;


    pub fn get_num_sub_iterations(&self) -> i32 {
        self.num_sub_iterations.unwrap_or(2i32)
    }
    pub fn clear_num_sub_iterations(&mut self) {
        self.num_sub_iterations = ::std::option::Option::None;
    }

    pub fn has_num_sub_iterations(&self) -> bool {
        self.num_sub_iterations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_sub_iterations(&mut self, v: i32) {
        self.num_sub_iterations = ::std::option::Option::Some(v);
    }

    // optional int32 max_sentencepiece_length = 20;


    pub fn get_max_sentencepiece_length(&self) -> i32 {
        self.max_sentencepiece_length.unwrap_or(16i32)
    }
    pub fn clear_max_sentencepiece_length(&mut self) {
        self.max_sentencepiece_length = ::std::option::Option::None;
    }

    pub fn has_max_sentencepiece_length(&self) -> bool {
        self.max_sentencepiece_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_sentencepiece_length(&mut self, v: i32) {
        self.max_sentencepiece_length = ::std::option::Option::Some(v);
    }

    // optional bool split_by_unicode_script = 21;


    pub fn get_split_by_unicode_script(&self) -> bool {
        self.split_by_unicode_script.unwrap_or(true)
    }
    pub fn clear_split_by_unicode_script(&mut self) {
        self.split_by_unicode_script = ::std::option::Option::None;
    }

    pub fn has_split_by_unicode_script(&self) -> bool {
        self.split_by_unicode_script.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_by_unicode_script(&mut self, v: bool) {
        self.split_by_unicode_script = ::std::option::Option::Some(v);
    }

    // optional bool split_by_number = 23;


    pub fn get_split_by_number(&self) -> bool {
        self.split_by_number.unwrap_or(true)
    }
    pub fn clear_split_by_number(&mut self) {
        self.split_by_number = ::std::option::Option::None;
    }

    pub fn has_split_by_number(&self) -> bool {
        self.split_by_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_by_number(&mut self, v: bool) {
        self.split_by_number = ::std::option::Option::Some(v);
    }

    // optional bool split_by_whitespace = 22;


    pub fn get_split_by_whitespace(&self) -> bool {
        self.split_by_whitespace.unwrap_or(true)
    }
    pub fn clear_split_by_whitespace(&mut self) {
        self.split_by_whitespace = ::std::option::Option::None;
    }

    pub fn has_split_by_whitespace(&self) -> bool {
        self.split_by_whitespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_by_whitespace(&mut self, v: bool) {
        self.split_by_whitespace = ::std::option::Option::Some(v);
    }

    // optional bool treat_whitespace_as_suffix = 24;


    pub fn get_treat_whitespace_as_suffix(&self) -> bool {
        self.treat_whitespace_as_suffix.unwrap_or(false)
    }
    pub fn clear_treat_whitespace_as_suffix(&mut self) {
        self.treat_whitespace_as_suffix = ::std::option::Option::None;
    }

    pub fn has_treat_whitespace_as_suffix(&self) -> bool {
        self.treat_whitespace_as_suffix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_treat_whitespace_as_suffix(&mut self, v: bool) {
        self.treat_whitespace_as_suffix = ::std::option::Option::Some(v);
    }

    // optional bool split_digits = 25;


    pub fn get_split_digits(&self) -> bool {
        self.split_digits.unwrap_or(false)
    }
    pub fn clear_split_digits(&mut self) {
        self.split_digits = ::std::option::Option::None;
    }

    pub fn has_split_digits(&self) -> bool {
        self.split_digits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_digits(&mut self, v: bool) {
        self.split_digits = ::std::option::Option::Some(v);
    }

    // repeated string control_symbols = 30;


    pub fn get_control_symbols(&self) -> &[::std::string::String] {
        &self.control_symbols
    }
    pub fn clear_control_symbols(&mut self) {
        self.control_symbols.clear();
    }

    // Param is passed by value, moved
    pub fn set_control_symbols(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.control_symbols = v;
    }

    // Mutable pointer to the field.
    pub fn mut_control_symbols(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.control_symbols
    }

    // Take field
    pub fn take_control_symbols(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.control_symbols, ::protobuf::RepeatedField::new())
    }

    // repeated string user_defined_symbols = 31;


    pub fn get_user_defined_symbols(&self) -> &[::std::string::String] {
        &self.user_defined_symbols
    }
    pub fn clear_user_defined_symbols(&mut self) {
        self.user_defined_symbols.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_defined_symbols(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_defined_symbols = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_defined_symbols(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_defined_symbols
    }

    // Take field
    pub fn take_user_defined_symbols(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_defined_symbols, ::protobuf::RepeatedField::new())
    }

    // optional string required_chars = 36;


    pub fn get_required_chars(&self) -> &str {
        match self.required_chars.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_required_chars(&mut self) {
        self.required_chars.clear();
    }

    pub fn has_required_chars(&self) -> bool {
        self.required_chars.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_chars(&mut self, v: ::std::string::String) {
        self.required_chars = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_required_chars(&mut self) -> &mut ::std::string::String {
        if self.required_chars.is_none() {
            self.required_chars.set_default();
        }
        self.required_chars.as_mut().unwrap()
    }

    // Take field
    pub fn take_required_chars(&mut self) -> ::std::string::String {
        self.required_chars.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool byte_fallback = 35;


    pub fn get_byte_fallback(&self) -> bool {
        self.byte_fallback.unwrap_or(false)
    }
    pub fn clear_byte_fallback(&mut self) {
        self.byte_fallback = ::std::option::Option::None;
    }

    pub fn has_byte_fallback(&self) -> bool {
        self.byte_fallback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_byte_fallback(&mut self, v: bool) {
        self.byte_fallback = ::std::option::Option::Some(v);
    }

    // optional bool vocabulary_output_piece_score = 32;


    pub fn get_vocabulary_output_piece_score(&self) -> bool {
        self.vocabulary_output_piece_score.unwrap_or(true)
    }
    pub fn clear_vocabulary_output_piece_score(&mut self) {
        self.vocabulary_output_piece_score = ::std::option::Option::None;
    }

    pub fn has_vocabulary_output_piece_score(&self) -> bool {
        self.vocabulary_output_piece_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vocabulary_output_piece_score(&mut self, v: bool) {
        self.vocabulary_output_piece_score = ::std::option::Option::Some(v);
    }

    // optional bool hard_vocab_limit = 33;


    pub fn get_hard_vocab_limit(&self) -> bool {
        self.hard_vocab_limit.unwrap_or(true)
    }
    pub fn clear_hard_vocab_limit(&mut self) {
        self.hard_vocab_limit = ::std::option::Option::None;
    }

    pub fn has_hard_vocab_limit(&self) -> bool {
        self.hard_vocab_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hard_vocab_limit(&mut self, v: bool) {
        self.hard_vocab_limit = ::std::option::Option::Some(v);
    }

    // optional bool use_all_vocab = 34;


    pub fn get_use_all_vocab(&self) -> bool {
        self.use_all_vocab.unwrap_or(false)
    }
    pub fn clear_use_all_vocab(&mut self) {
        self.use_all_vocab = ::std::option::Option::None;
    }

    pub fn has_use_all_vocab(&self) -> bool {
        self.use_all_vocab.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_all_vocab(&mut self, v: bool) {
        self.use_all_vocab = ::std::option::Option::Some(v);
    }

    // optional int32 unk_id = 40;


    pub fn get_unk_id(&self) -> i32 {
        self.unk_id.unwrap_or(0i32)
    }
    pub fn clear_unk_id(&mut self) {
        self.unk_id = ::std::option::Option::None;
    }

    pub fn has_unk_id(&self) -> bool {
        self.unk_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unk_id(&mut self, v: i32) {
        self.unk_id = ::std::option::Option::Some(v);
    }

    // optional int32 bos_id = 41;


    pub fn get_bos_id(&self) -> i32 {
        self.bos_id.unwrap_or(1i32)
    }
    pub fn clear_bos_id(&mut self) {
        self.bos_id = ::std::option::Option::None;
    }

    pub fn has_bos_id(&self) -> bool {
        self.bos_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bos_id(&mut self, v: i32) {
        self.bos_id = ::std::option::Option::Some(v);
    }

    // optional int32 eos_id = 42;


    pub fn get_eos_id(&self) -> i32 {
        self.eos_id.unwrap_or(2i32)
    }
    pub fn clear_eos_id(&mut self) {
        self.eos_id = ::std::option::Option::None;
    }

    pub fn has_eos_id(&self) -> bool {
        self.eos_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eos_id(&mut self, v: i32) {
        self.eos_id = ::std::option::Option::Some(v);
    }

    // optional int32 pad_id = 43;


    pub fn get_pad_id(&self) -> i32 {
        self.pad_id.unwrap_or(-1i32)
    }
    pub fn clear_pad_id(&mut self) {
        self.pad_id = ::std::option::Option::None;
    }

    pub fn has_pad_id(&self) -> bool {
        self.pad_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pad_id(&mut self, v: i32) {
        self.pad_id = ::std::option::Option::Some(v);
    }

    // optional string unk_piece = 45;


    pub fn get_unk_piece(&self) -> &str {
        match self.unk_piece.as_ref() {
            Some(v) => &v,
            None => "<unk>",
        }
    }
    pub fn clear_unk_piece(&mut self) {
        self.unk_piece.clear();
    }

    pub fn has_unk_piece(&self) -> bool {
        self.unk_piece.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unk_piece(&mut self, v: ::std::string::String) {
        self.unk_piece = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unk_piece(&mut self) -> &mut ::std::string::String {
        if self.unk_piece.is_none() {
            self.unk_piece.set_default();
        }
        self.unk_piece.as_mut().unwrap()
    }

    // Take field
    pub fn take_unk_piece(&mut self) -> ::std::string::String {
        self.unk_piece.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bos_piece = 46;


    pub fn get_bos_piece(&self) -> &str {
        match self.bos_piece.as_ref() {
            Some(v) => &v,
            None => "<s>",
        }
    }
    pub fn clear_bos_piece(&mut self) {
        self.bos_piece.clear();
    }

    pub fn has_bos_piece(&self) -> bool {
        self.bos_piece.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bos_piece(&mut self, v: ::std::string::String) {
        self.bos_piece = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bos_piece(&mut self) -> &mut ::std::string::String {
        if self.bos_piece.is_none() {
            self.bos_piece.set_default();
        }
        self.bos_piece.as_mut().unwrap()
    }

    // Take field
    pub fn take_bos_piece(&mut self) -> ::std::string::String {
        self.bos_piece.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string eos_piece = 47;


    pub fn get_eos_piece(&self) -> &str {
        match self.eos_piece.as_ref() {
            Some(v) => &v,
            None => "</s>",
        }
    }
    pub fn clear_eos_piece(&mut self) {
        self.eos_piece.clear();
    }

    pub fn has_eos_piece(&self) -> bool {
        self.eos_piece.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eos_piece(&mut self, v: ::std::string::String) {
        self.eos_piece = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eos_piece(&mut self) -> &mut ::std::string::String {
        if self.eos_piece.is_none() {
            self.eos_piece.set_default();
        }
        self.eos_piece.as_mut().unwrap()
    }

    // Take field
    pub fn take_eos_piece(&mut self) -> ::std::string::String {
        self.eos_piece.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pad_piece = 48;


    pub fn get_pad_piece(&self) -> &str {
        match self.pad_piece.as_ref() {
            Some(v) => &v,
            None => "<pad>",
        }
    }
    pub fn clear_pad_piece(&mut self) {
        self.pad_piece.clear();
    }

    pub fn has_pad_piece(&self) -> bool {
        self.pad_piece.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pad_piece(&mut self, v: ::std::string::String) {
        self.pad_piece = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pad_piece(&mut self) -> &mut ::std::string::String {
        if self.pad_piece.is_none() {
            self.pad_piece.set_default();
        }
        self.pad_piece.as_mut().unwrap()
    }

    // Take field
    pub fn take_pad_piece(&mut self) -> ::std::string::String {
        self.pad_piece.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string unk_surface = 44;


    pub fn get_unk_surface(&self) -> &str {
        match self.unk_surface.as_ref() {
            Some(v) => &v,
            None => " \u{e2}\u{81}\u{87} ",
        }
    }
    pub fn clear_unk_surface(&mut self) {
        self.unk_surface.clear();
    }

    pub fn has_unk_surface(&self) -> bool {
        self.unk_surface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unk_surface(&mut self, v: ::std::string::String) {
        self.unk_surface = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unk_surface(&mut self) -> &mut ::std::string::String {
        if self.unk_surface.is_none() {
            self.unk_surface.set_default();
        }
        self.unk_surface.as_mut().unwrap()
    }

    // Take field
    pub fn take_unk_surface(&mut self) -> ::std::string::String {
        self.unk_surface.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool train_extremely_large_corpus = 49;


    pub fn get_train_extremely_large_corpus(&self) -> bool {
        self.train_extremely_large_corpus.unwrap_or(false)
    }
    pub fn clear_train_extremely_large_corpus(&mut self) {
        self.train_extremely_large_corpus = ::std::option::Option::None;
    }

    pub fn has_train_extremely_large_corpus(&self) -> bool {
        self.train_extremely_large_corpus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_train_extremely_large_corpus(&mut self, v: bool) {
        self.train_extremely_large_corpus = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TrainerSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.input)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.input_format)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.model_prefix)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.model_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.vocab_size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.accept_language)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.self_test_sample_size = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.character_coverage = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.input_sentence_size = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.shuffle_input_sentence = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mining_sentence_size = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.training_sentence_size = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seed_sentencepiece_size = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.shrinking_factor = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_sentence_length = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_threads = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_sub_iterations = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_sentencepiece_length = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.split_by_unicode_script = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.split_by_number = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.split_by_whitespace = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.treat_whitespace_as_suffix = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.split_digits = ::std::option::Option::Some(tmp);
                },
                30 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.control_symbols)?;
                },
                31 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_defined_symbols)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.required_chars)?;
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.byte_fallback = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.vocabulary_output_piece_score = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hard_vocab_limit = ::std::option::Option::Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_all_vocab = ::std::option::Option::Some(tmp);
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unk_id = ::std::option::Option::Some(tmp);
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bos_id = ::std::option::Option::Some(tmp);
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eos_id = ::std::option::Option::Some(tmp);
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pad_id = ::std::option::Option::Some(tmp);
                },
                45 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.unk_piece)?;
                },
                46 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bos_piece)?;
                },
                47 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.eos_piece)?;
                },
                48 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pad_piece)?;
                },
                44 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.unk_surface)?;
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.train_extremely_large_corpus = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.input {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.input_format.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.model_prefix.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.model_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.vocab_size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.accept_language {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.self_test_sample_size {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.character_coverage {
            my_size += 5;
        }
        if let Some(v) = self.input_sentence_size {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shuffle_input_sentence {
            my_size += 3;
        }
        if let Some(v) = self.mining_sentence_size {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.training_sentence_size {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seed_sentencepiece_size {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shrinking_factor {
            my_size += 5;
        }
        if let Some(v) = self.max_sentence_length {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_threads {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_sub_iterations {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_sentencepiece_length {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.split_by_unicode_script {
            my_size += 3;
        }
        if let Some(v) = self.split_by_number {
            my_size += 3;
        }
        if let Some(v) = self.split_by_whitespace {
            my_size += 3;
        }
        if let Some(v) = self.treat_whitespace_as_suffix {
            my_size += 3;
        }
        if let Some(v) = self.split_digits {
            my_size += 3;
        }
        for value in &self.control_symbols {
            my_size += ::protobuf::rt::string_size(30, &value);
        };
        for value in &self.user_defined_symbols {
            my_size += ::protobuf::rt::string_size(31, &value);
        };
        if let Some(ref v) = self.required_chars.as_ref() {
            my_size += ::protobuf::rt::string_size(36, &v);
        }
        if let Some(v) = self.byte_fallback {
            my_size += 3;
        }
        if let Some(v) = self.vocabulary_output_piece_score {
            my_size += 3;
        }
        if let Some(v) = self.hard_vocab_limit {
            my_size += 3;
        }
        if let Some(v) = self.use_all_vocab {
            my_size += 3;
        }
        if let Some(v) = self.unk_id {
            my_size += ::protobuf::rt::value_size(40, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bos_id {
            my_size += ::protobuf::rt::value_size(41, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.eos_id {
            my_size += ::protobuf::rt::value_size(42, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pad_id {
            my_size += ::protobuf::rt::value_size(43, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.unk_piece.as_ref() {
            my_size += ::protobuf::rt::string_size(45, &v);
        }
        if let Some(ref v) = self.bos_piece.as_ref() {
            my_size += ::protobuf::rt::string_size(46, &v);
        }
        if let Some(ref v) = self.eos_piece.as_ref() {
            my_size += ::protobuf::rt::string_size(47, &v);
        }
        if let Some(ref v) = self.pad_piece.as_ref() {
            my_size += ::protobuf::rt::string_size(48, &v);
        }
        if let Some(ref v) = self.unk_surface.as_ref() {
            my_size += ::protobuf::rt::string_size(44, &v);
        }
        if let Some(v) = self.train_extremely_large_corpus {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.input {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.input_format.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.model_prefix.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.model_type {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.vocab_size {
            os.write_int32(4, v)?;
        }
        for v in &self.accept_language {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.self_test_sample_size {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.character_coverage {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.input_sentence_size {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.shuffle_input_sentence {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.mining_sentence_size {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.training_sentence_size {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.seed_sentencepiece_size {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.shrinking_factor {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.max_sentence_length {
            os.write_int32(18, v)?;
        }
        if let Some(v) = self.num_threads {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.num_sub_iterations {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.max_sentencepiece_length {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.split_by_unicode_script {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.split_by_number {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.split_by_whitespace {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.treat_whitespace_as_suffix {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.split_digits {
            os.write_bool(25, v)?;
        }
        for v in &self.control_symbols {
            os.write_string(30, &v)?;
        };
        for v in &self.user_defined_symbols {
            os.write_string(31, &v)?;
        };
        if let Some(ref v) = self.required_chars.as_ref() {
            os.write_string(36, &v)?;
        }
        if let Some(v) = self.byte_fallback {
            os.write_bool(35, v)?;
        }
        if let Some(v) = self.vocabulary_output_piece_score {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.hard_vocab_limit {
            os.write_bool(33, v)?;
        }
        if let Some(v) = self.use_all_vocab {
            os.write_bool(34, v)?;
        }
        if let Some(v) = self.unk_id {
            os.write_int32(40, v)?;
        }
        if let Some(v) = self.bos_id {
            os.write_int32(41, v)?;
        }
        if let Some(v) = self.eos_id {
            os.write_int32(42, v)?;
        }
        if let Some(v) = self.pad_id {
            os.write_int32(43, v)?;
        }
        if let Some(ref v) = self.unk_piece.as_ref() {
            os.write_string(45, &v)?;
        }
        if let Some(ref v) = self.bos_piece.as_ref() {
            os.write_string(46, &v)?;
        }
        if let Some(ref v) = self.eos_piece.as_ref() {
            os.write_string(47, &v)?;
        }
        if let Some(ref v) = self.pad_piece.as_ref() {
            os.write_string(48, &v)?;
        }
        if let Some(ref v) = self.unk_surface.as_ref() {
            os.write_string(44, &v)?;
        }
        if let Some(v) = self.train_extremely_large_corpus {
            os.write_bool(49, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrainerSpec {
        TrainerSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "input",
                    |m: &TrainerSpec| { &m.input },
                    |m: &mut TrainerSpec| { &mut m.input },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "input_format",
                    |m: &TrainerSpec| { &m.input_format },
                    |m: &mut TrainerSpec| { &mut m.input_format },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "model_prefix",
                    |m: &TrainerSpec| { &m.model_prefix },
                    |m: &mut TrainerSpec| { &mut m.model_prefix },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TrainerSpec_ModelType>>(
                    "model_type",
                    |m: &TrainerSpec| { &m.model_type },
                    |m: &mut TrainerSpec| { &mut m.model_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "vocab_size",
                    |m: &TrainerSpec| { &m.vocab_size },
                    |m: &mut TrainerSpec| { &mut m.vocab_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "accept_language",
                    |m: &TrainerSpec| { &m.accept_language },
                    |m: &mut TrainerSpec| { &mut m.accept_language },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "self_test_sample_size",
                    |m: &TrainerSpec| { &m.self_test_sample_size },
                    |m: &mut TrainerSpec| { &mut m.self_test_sample_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "character_coverage",
                    |m: &TrainerSpec| { &m.character_coverage },
                    |m: &mut TrainerSpec| { &mut m.character_coverage },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "input_sentence_size",
                    |m: &TrainerSpec| { &m.input_sentence_size },
                    |m: &mut TrainerSpec| { &mut m.input_sentence_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "shuffle_input_sentence",
                    |m: &TrainerSpec| { &m.shuffle_input_sentence },
                    |m: &mut TrainerSpec| { &mut m.shuffle_input_sentence },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mining_sentence_size",
                    |m: &TrainerSpec| { &m.mining_sentence_size },
                    |m: &mut TrainerSpec| { &mut m.mining_sentence_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "training_sentence_size",
                    |m: &TrainerSpec| { &m.training_sentence_size },
                    |m: &mut TrainerSpec| { &mut m.training_sentence_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "seed_sentencepiece_size",
                    |m: &TrainerSpec| { &m.seed_sentencepiece_size },
                    |m: &mut TrainerSpec| { &mut m.seed_sentencepiece_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "shrinking_factor",
                    |m: &TrainerSpec| { &m.shrinking_factor },
                    |m: &mut TrainerSpec| { &mut m.shrinking_factor },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "max_sentence_length",
                    |m: &TrainerSpec| { &m.max_sentence_length },
                    |m: &mut TrainerSpec| { &mut m.max_sentence_length },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_threads",
                    |m: &TrainerSpec| { &m.num_threads },
                    |m: &mut TrainerSpec| { &mut m.num_threads },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_sub_iterations",
                    |m: &TrainerSpec| { &m.num_sub_iterations },
                    |m: &mut TrainerSpec| { &mut m.num_sub_iterations },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "max_sentencepiece_length",
                    |m: &TrainerSpec| { &m.max_sentencepiece_length },
                    |m: &mut TrainerSpec| { &mut m.max_sentencepiece_length },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "split_by_unicode_script",
                    |m: &TrainerSpec| { &m.split_by_unicode_script },
                    |m: &mut TrainerSpec| { &mut m.split_by_unicode_script },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "split_by_number",
                    |m: &TrainerSpec| { &m.split_by_number },
                    |m: &mut TrainerSpec| { &mut m.split_by_number },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "split_by_whitespace",
                    |m: &TrainerSpec| { &m.split_by_whitespace },
                    |m: &mut TrainerSpec| { &mut m.split_by_whitespace },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "treat_whitespace_as_suffix",
                    |m: &TrainerSpec| { &m.treat_whitespace_as_suffix },
                    |m: &mut TrainerSpec| { &mut m.treat_whitespace_as_suffix },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "split_digits",
                    |m: &TrainerSpec| { &m.split_digits },
                    |m: &mut TrainerSpec| { &mut m.split_digits },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "control_symbols",
                    |m: &TrainerSpec| { &m.control_symbols },
                    |m: &mut TrainerSpec| { &mut m.control_symbols },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_defined_symbols",
                    |m: &TrainerSpec| { &m.user_defined_symbols },
                    |m: &mut TrainerSpec| { &mut m.user_defined_symbols },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "required_chars",
                    |m: &TrainerSpec| { &m.required_chars },
                    |m: &mut TrainerSpec| { &mut m.required_chars },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "byte_fallback",
                    |m: &TrainerSpec| { &m.byte_fallback },
                    |m: &mut TrainerSpec| { &mut m.byte_fallback },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "vocabulary_output_piece_score",
                    |m: &TrainerSpec| { &m.vocabulary_output_piece_score },
                    |m: &mut TrainerSpec| { &mut m.vocabulary_output_piece_score },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hard_vocab_limit",
                    |m: &TrainerSpec| { &m.hard_vocab_limit },
                    |m: &mut TrainerSpec| { &mut m.hard_vocab_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "use_all_vocab",
                    |m: &TrainerSpec| { &m.use_all_vocab },
                    |m: &mut TrainerSpec| { &mut m.use_all_vocab },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "unk_id",
                    |m: &TrainerSpec| { &m.unk_id },
                    |m: &mut TrainerSpec| { &mut m.unk_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "bos_id",
                    |m: &TrainerSpec| { &m.bos_id },
                    |m: &mut TrainerSpec| { &mut m.bos_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "eos_id",
                    |m: &TrainerSpec| { &m.eos_id },
                    |m: &mut TrainerSpec| { &mut m.eos_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "pad_id",
                    |m: &TrainerSpec| { &m.pad_id },
                    |m: &mut TrainerSpec| { &mut m.pad_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "unk_piece",
                    |m: &TrainerSpec| { &m.unk_piece },
                    |m: &mut TrainerSpec| { &mut m.unk_piece },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bos_piece",
                    |m: &TrainerSpec| { &m.bos_piece },
                    |m: &mut TrainerSpec| { &mut m.bos_piece },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "eos_piece",
                    |m: &TrainerSpec| { &m.eos_piece },
                    |m: &mut TrainerSpec| { &mut m.eos_piece },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pad_piece",
                    |m: &TrainerSpec| { &m.pad_piece },
                    |m: &mut TrainerSpec| { &mut m.pad_piece },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "unk_surface",
                    |m: &TrainerSpec| { &m.unk_surface },
                    |m: &mut TrainerSpec| { &mut m.unk_surface },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "train_extremely_large_corpus",
                    |m: &TrainerSpec| { &m.train_extremely_large_corpus },
                    |m: &mut TrainerSpec| { &mut m.train_extremely_large_corpus },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrainerSpec>(
                    "TrainerSpec",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TrainerSpec {
        static mut instance: ::protobuf::lazy::Lazy<TrainerSpec> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TrainerSpec::new)
        }
    }
}

impl ::protobuf::Clear for TrainerSpec {
    fn clear(&mut self) {
        self.input.clear();
        self.input_format.clear();
        self.model_prefix.clear();
        self.model_type = ::std::option::Option::None;
        self.vocab_size = ::std::option::Option::None;
        self.accept_language.clear();
        self.self_test_sample_size = ::std::option::Option::None;
        self.character_coverage = ::std::option::Option::None;
        self.input_sentence_size = ::std::option::Option::None;
        self.shuffle_input_sentence = ::std::option::Option::None;
        self.mining_sentence_size = ::std::option::Option::None;
        self.training_sentence_size = ::std::option::Option::None;
        self.seed_sentencepiece_size = ::std::option::Option::None;
        self.shrinking_factor = ::std::option::Option::None;
        self.max_sentence_length = ::std::option::Option::None;
        self.num_threads = ::std::option::Option::None;
        self.num_sub_iterations = ::std::option::Option::None;
        self.max_sentencepiece_length = ::std::option::Option::None;
        self.split_by_unicode_script = ::std::option::Option::None;
        self.split_by_number = ::std::option::Option::None;
        self.split_by_whitespace = ::std::option::Option::None;
        self.treat_whitespace_as_suffix = ::std::option::Option::None;
        self.split_digits = ::std::option::Option::None;
        self.control_symbols.clear();
        self.user_defined_symbols.clear();
        self.required_chars.clear();
        self.byte_fallback = ::std::option::Option::None;
        self.vocabulary_output_piece_score = ::std::option::Option::None;
        self.hard_vocab_limit = ::std::option::Option::None;
        self.use_all_vocab = ::std::option::Option::None;
        self.unk_id = ::std::option::Option::None;
        self.bos_id = ::std::option::Option::None;
        self.eos_id = ::std::option::Option::None;
        self.pad_id = ::std::option::Option::None;
        self.unk_piece.clear();
        self.bos_piece.clear();
        self.eos_piece.clear();
        self.pad_piece.clear();
        self.unk_surface.clear();
        self.train_extremely_large_corpus = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrainerSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainerSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TrainerSpec_ModelType {
    UNIGRAM = 1,
    BPE = 2,
    WORD = 3,
    CHAR = 4,
}

impl ::protobuf::ProtobufEnum for TrainerSpec_ModelType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TrainerSpec_ModelType> {
        match value {
            1 => ::std::option::Option::Some(TrainerSpec_ModelType::UNIGRAM),
            2 => ::std::option::Option::Some(TrainerSpec_ModelType::BPE),
            3 => ::std::option::Option::Some(TrainerSpec_ModelType::WORD),
            4 => ::std::option::Option::Some(TrainerSpec_ModelType::CHAR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TrainerSpec_ModelType] = &[
            TrainerSpec_ModelType::UNIGRAM,
            TrainerSpec_ModelType::BPE,
            TrainerSpec_ModelType::WORD,
            TrainerSpec_ModelType::CHAR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<TrainerSpec_ModelType>("TrainerSpec.ModelType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TrainerSpec_ModelType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TrainerSpec_ModelType {
    fn default() -> Self {
        TrainerSpec_ModelType::UNIGRAM
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainerSpec_ModelType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NormalizerSpec {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    precompiled_charsmap: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    add_dummy_prefix: ::std::option::Option<bool>,
    remove_extra_whitespaces: ::std::option::Option<bool>,
    escape_whitespaces: ::std::option::Option<bool>,
    normalization_rule_tsv: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NormalizerSpec {
    fn default() -> &'a NormalizerSpec {
        <NormalizerSpec as ::protobuf::Message>::default_instance()
    }
}

impl NormalizerSpec {
    pub fn new() -> NormalizerSpec {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes precompiled_charsmap = 2;


    pub fn get_precompiled_charsmap(&self) -> &[u8] {
        match self.precompiled_charsmap.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_precompiled_charsmap(&mut self) {
        self.precompiled_charsmap.clear();
    }

    pub fn has_precompiled_charsmap(&self) -> bool {
        self.precompiled_charsmap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_precompiled_charsmap(&mut self, v: ::std::vec::Vec<u8>) {
        self.precompiled_charsmap = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_precompiled_charsmap(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.precompiled_charsmap.is_none() {
            self.precompiled_charsmap.set_default();
        }
        self.precompiled_charsmap.as_mut().unwrap()
    }

    // Take field
    pub fn take_precompiled_charsmap(&mut self) -> ::std::vec::Vec<u8> {
        self.precompiled_charsmap.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool add_dummy_prefix = 3;


    pub fn get_add_dummy_prefix(&self) -> bool {
        self.add_dummy_prefix.unwrap_or(true)
    }
    pub fn clear_add_dummy_prefix(&mut self) {
        self.add_dummy_prefix = ::std::option::Option::None;
    }

    pub fn has_add_dummy_prefix(&self) -> bool {
        self.add_dummy_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_dummy_prefix(&mut self, v: bool) {
        self.add_dummy_prefix = ::std::option::Option::Some(v);
    }

    // optional bool remove_extra_whitespaces = 4;


    pub fn get_remove_extra_whitespaces(&self) -> bool {
        self.remove_extra_whitespaces.unwrap_or(true)
    }
    pub fn clear_remove_extra_whitespaces(&mut self) {
        self.remove_extra_whitespaces = ::std::option::Option::None;
    }

    pub fn has_remove_extra_whitespaces(&self) -> bool {
        self.remove_extra_whitespaces.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove_extra_whitespaces(&mut self, v: bool) {
        self.remove_extra_whitespaces = ::std::option::Option::Some(v);
    }

    // optional bool escape_whitespaces = 5;


    pub fn get_escape_whitespaces(&self) -> bool {
        self.escape_whitespaces.unwrap_or(true)
    }
    pub fn clear_escape_whitespaces(&mut self) {
        self.escape_whitespaces = ::std::option::Option::None;
    }

    pub fn has_escape_whitespaces(&self) -> bool {
        self.escape_whitespaces.is_some()
    }

    // Param is passed by value, moved
    pub fn set_escape_whitespaces(&mut self, v: bool) {
        self.escape_whitespaces = ::std::option::Option::Some(v);
    }

    // optional string normalization_rule_tsv = 6;


    pub fn get_normalization_rule_tsv(&self) -> &str {
        match self.normalization_rule_tsv.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_normalization_rule_tsv(&mut self) {
        self.normalization_rule_tsv.clear();
    }

    pub fn has_normalization_rule_tsv(&self) -> bool {
        self.normalization_rule_tsv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normalization_rule_tsv(&mut self, v: ::std::string::String) {
        self.normalization_rule_tsv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_normalization_rule_tsv(&mut self) -> &mut ::std::string::String {
        if self.normalization_rule_tsv.is_none() {
            self.normalization_rule_tsv.set_default();
        }
        self.normalization_rule_tsv.as_mut().unwrap()
    }

    // Take field
    pub fn take_normalization_rule_tsv(&mut self) -> ::std::string::String {
        self.normalization_rule_tsv.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for NormalizerSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.precompiled_charsmap)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.add_dummy_prefix = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remove_extra_whitespaces = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.escape_whitespaces = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.normalization_rule_tsv)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.precompiled_charsmap.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.add_dummy_prefix {
            my_size += 2;
        }
        if let Some(v) = self.remove_extra_whitespaces {
            my_size += 2;
        }
        if let Some(v) = self.escape_whitespaces {
            my_size += 2;
        }
        if let Some(ref v) = self.normalization_rule_tsv.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.precompiled_charsmap.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.add_dummy_prefix {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.remove_extra_whitespaces {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.escape_whitespaces {
            os.write_bool(5, v)?;
        }
        if let Some(ref v) = self.normalization_rule_tsv.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NormalizerSpec {
        NormalizerSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &NormalizerSpec| { &m.name },
                    |m: &mut NormalizerSpec| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "precompiled_charsmap",
                    |m: &NormalizerSpec| { &m.precompiled_charsmap },
                    |m: &mut NormalizerSpec| { &mut m.precompiled_charsmap },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "add_dummy_prefix",
                    |m: &NormalizerSpec| { &m.add_dummy_prefix },
                    |m: &mut NormalizerSpec| { &mut m.add_dummy_prefix },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "remove_extra_whitespaces",
                    |m: &NormalizerSpec| { &m.remove_extra_whitespaces },
                    |m: &mut NormalizerSpec| { &mut m.remove_extra_whitespaces },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "escape_whitespaces",
                    |m: &NormalizerSpec| { &m.escape_whitespaces },
                    |m: &mut NormalizerSpec| { &mut m.escape_whitespaces },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "normalization_rule_tsv",
                    |m: &NormalizerSpec| { &m.normalization_rule_tsv },
                    |m: &mut NormalizerSpec| { &mut m.normalization_rule_tsv },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<NormalizerSpec>(
                    "NormalizerSpec",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NormalizerSpec {
        static mut instance: ::protobuf::lazy::Lazy<NormalizerSpec> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(NormalizerSpec::new)
        }
    }
}

impl ::protobuf::Clear for NormalizerSpec {
    fn clear(&mut self) {
        self.name.clear();
        self.precompiled_charsmap.clear();
        self.add_dummy_prefix = ::std::option::Option::None;
        self.remove_extra_whitespaces = ::std::option::Option::None;
        self.escape_whitespaces = ::std::option::Option::None;
        self.normalization_rule_tsv.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NormalizerSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NormalizerSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SelfTestData {
    // message fields
    samples: ::protobuf::RepeatedField<SelfTestData_Sample>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SelfTestData {
    fn default() -> &'a SelfTestData {
        <SelfTestData as ::protobuf::Message>::default_instance()
    }
}

impl SelfTestData {
    pub fn new() -> SelfTestData {
        ::std::default::Default::default()
    }

    // repeated .sentencepiece.SelfTestData.Sample samples = 1;


    pub fn get_samples(&self) -> &[SelfTestData_Sample] {
        &self.samples
    }
    pub fn clear_samples(&mut self) {
        self.samples.clear();
    }

    // Param is passed by value, moved
    pub fn set_samples(&mut self, v: ::protobuf::RepeatedField<SelfTestData_Sample>) {
        self.samples = v;
    }

    // Mutable pointer to the field.
    pub fn mut_samples(&mut self) -> &mut ::protobuf::RepeatedField<SelfTestData_Sample> {
        &mut self.samples
    }

    // Take field
    pub fn take_samples(&mut self) -> ::protobuf::RepeatedField<SelfTestData_Sample> {
        ::std::mem::replace(&mut self.samples, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SelfTestData {
    fn is_initialized(&self) -> bool {
        for v in &self.samples {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.samples)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.samples {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.samples {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelfTestData {
        SelfTestData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SelfTestData_Sample>>(
                    "samples",
                    |m: &SelfTestData| { &m.samples },
                    |m: &mut SelfTestData| { &mut m.samples },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SelfTestData>(
                    "SelfTestData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SelfTestData {
        static mut instance: ::protobuf::lazy::Lazy<SelfTestData> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SelfTestData::new)
        }
    }
}

impl ::protobuf::Clear for SelfTestData {
    fn clear(&mut self) {
        self.samples.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SelfTestData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelfTestData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SelfTestData_Sample {
    // message fields
    input: ::protobuf::SingularField<::std::string::String>,
    expected: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SelfTestData_Sample {
    fn default() -> &'a SelfTestData_Sample {
        <SelfTestData_Sample as ::protobuf::Message>::default_instance()
    }
}

impl SelfTestData_Sample {
    pub fn new() -> SelfTestData_Sample {
        ::std::default::Default::default()
    }

    // optional string input = 1;


    pub fn get_input(&self) -> &str {
        match self.input.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    pub fn has_input(&self) -> bool {
        self.input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: ::std::string::String) {
        self.input = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input(&mut self) -> &mut ::std::string::String {
        if self.input.is_none() {
            self.input.set_default();
        }
        self.input.as_mut().unwrap()
    }

    // Take field
    pub fn take_input(&mut self) -> ::std::string::String {
        self.input.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string expected = 2;


    pub fn get_expected(&self) -> &str {
        match self.expected.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_expected(&mut self) {
        self.expected.clear();
    }

    pub fn has_expected(&self) -> bool {
        self.expected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expected(&mut self, v: ::std::string::String) {
        self.expected = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expected(&mut self) -> &mut ::std::string::String {
        if self.expected.is_none() {
            self.expected.set_default();
        }
        self.expected.as_mut().unwrap()
    }

    // Take field
    pub fn take_expected(&mut self) -> ::std::string::String {
        self.expected.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for SelfTestData_Sample {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.input)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.expected)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.input.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.expected.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.input.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.expected.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelfTestData_Sample {
        SelfTestData_Sample::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "input",
                    |m: &SelfTestData_Sample| { &m.input },
                    |m: &mut SelfTestData_Sample| { &mut m.input },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "expected",
                    |m: &SelfTestData_Sample| { &m.expected },
                    |m: &mut SelfTestData_Sample| { &mut m.expected },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SelfTestData_Sample>(
                    "SelfTestData.Sample",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SelfTestData_Sample {
        static mut instance: ::protobuf::lazy::Lazy<SelfTestData_Sample> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SelfTestData_Sample::new)
        }
    }
}

impl ::protobuf::Clear for SelfTestData_Sample {
    fn clear(&mut self) {
        self.input.clear();
        self.expected.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SelfTestData_Sample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelfTestData_Sample {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModelProto {
    // message fields
    pieces: ::protobuf::RepeatedField<ModelProto_SentencePiece>,
    trainer_spec: ::protobuf::SingularPtrField<TrainerSpec>,
    normalizer_spec: ::protobuf::SingularPtrField<NormalizerSpec>,
    self_test_data: ::protobuf::SingularPtrField<SelfTestData>,
    denormalizer_spec: ::protobuf::SingularPtrField<NormalizerSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModelProto {
    fn default() -> &'a ModelProto {
        <ModelProto as ::protobuf::Message>::default_instance()
    }
}

impl ModelProto {
    pub fn new() -> ModelProto {
        ::std::default::Default::default()
    }

    // repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;


    pub fn get_pieces(&self) -> &[ModelProto_SentencePiece] {
        &self.pieces
    }
    pub fn clear_pieces(&mut self) {
        self.pieces.clear();
    }

    // Param is passed by value, moved
    pub fn set_pieces(&mut self, v: ::protobuf::RepeatedField<ModelProto_SentencePiece>) {
        self.pieces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pieces(&mut self) -> &mut ::protobuf::RepeatedField<ModelProto_SentencePiece> {
        &mut self.pieces
    }

    // Take field
    pub fn take_pieces(&mut self) -> ::protobuf::RepeatedField<ModelProto_SentencePiece> {
        ::std::mem::replace(&mut self.pieces, ::protobuf::RepeatedField::new())
    }

    // optional .sentencepiece.TrainerSpec trainer_spec = 2;


    pub fn get_trainer_spec(&self) -> &TrainerSpec {
        self.trainer_spec.as_ref().unwrap_or_else(|| TrainerSpec::default_instance())
    }
    pub fn clear_trainer_spec(&mut self) {
        self.trainer_spec.clear();
    }

    pub fn has_trainer_spec(&self) -> bool {
        self.trainer_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trainer_spec(&mut self, v: TrainerSpec) {
        self.trainer_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trainer_spec(&mut self) -> &mut TrainerSpec {
        if self.trainer_spec.is_none() {
            self.trainer_spec.set_default();
        }
        self.trainer_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_trainer_spec(&mut self) -> TrainerSpec {
        self.trainer_spec.take().unwrap_or_else(|| TrainerSpec::new())
    }

    // optional .sentencepiece.NormalizerSpec normalizer_spec = 3;


    pub fn get_normalizer_spec(&self) -> &NormalizerSpec {
        self.normalizer_spec.as_ref().unwrap_or_else(|| NormalizerSpec::default_instance())
    }
    pub fn clear_normalizer_spec(&mut self) {
        self.normalizer_spec.clear();
    }

    pub fn has_normalizer_spec(&self) -> bool {
        self.normalizer_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normalizer_spec(&mut self, v: NormalizerSpec) {
        self.normalizer_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_normalizer_spec(&mut self) -> &mut NormalizerSpec {
        if self.normalizer_spec.is_none() {
            self.normalizer_spec.set_default();
        }
        self.normalizer_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_normalizer_spec(&mut self) -> NormalizerSpec {
        self.normalizer_spec.take().unwrap_or_else(|| NormalizerSpec::new())
    }

    // optional .sentencepiece.SelfTestData self_test_data = 4;


    pub fn get_self_test_data(&self) -> &SelfTestData {
        self.self_test_data.as_ref().unwrap_or_else(|| SelfTestData::default_instance())
    }
    pub fn clear_self_test_data(&mut self) {
        self.self_test_data.clear();
    }

    pub fn has_self_test_data(&self) -> bool {
        self.self_test_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_self_test_data(&mut self, v: SelfTestData) {
        self.self_test_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_self_test_data(&mut self) -> &mut SelfTestData {
        if self.self_test_data.is_none() {
            self.self_test_data.set_default();
        }
        self.self_test_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_self_test_data(&mut self) -> SelfTestData {
        self.self_test_data.take().unwrap_or_else(|| SelfTestData::new())
    }

    // optional .sentencepiece.NormalizerSpec denormalizer_spec = 5;


    pub fn get_denormalizer_spec(&self) -> &NormalizerSpec {
        self.denormalizer_spec.as_ref().unwrap_or_else(|| NormalizerSpec::default_instance())
    }
    pub fn clear_denormalizer_spec(&mut self) {
        self.denormalizer_spec.clear();
    }

    pub fn has_denormalizer_spec(&self) -> bool {
        self.denormalizer_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denormalizer_spec(&mut self, v: NormalizerSpec) {
        self.denormalizer_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denormalizer_spec(&mut self) -> &mut NormalizerSpec {
        if self.denormalizer_spec.is_none() {
            self.denormalizer_spec.set_default();
        }
        self.denormalizer_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_denormalizer_spec(&mut self) -> NormalizerSpec {
        self.denormalizer_spec.take().unwrap_or_else(|| NormalizerSpec::new())
    }
}

impl ::protobuf::Message for ModelProto {
    fn is_initialized(&self) -> bool {
        for v in &self.pieces {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trainer_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.normalizer_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.self_test_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.denormalizer_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pieces)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trainer_spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.normalizer_spec)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.self_test_data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.denormalizer_spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.pieces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.trainer_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.normalizer_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.self_test_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.denormalizer_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.pieces {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.trainer_spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.normalizer_spec.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.self_test_data.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.denormalizer_spec.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelProto {
        ModelProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModelProto_SentencePiece>>(
                    "pieces",
                    |m: &ModelProto| { &m.pieces },
                    |m: &mut ModelProto| { &mut m.pieces },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TrainerSpec>>(
                    "trainer_spec",
                    |m: &ModelProto| { &m.trainer_spec },
                    |m: &mut ModelProto| { &mut m.trainer_spec },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NormalizerSpec>>(
                    "normalizer_spec",
                    |m: &ModelProto| { &m.normalizer_spec },
                    |m: &mut ModelProto| { &mut m.normalizer_spec },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SelfTestData>>(
                    "self_test_data",
                    |m: &ModelProto| { &m.self_test_data },
                    |m: &mut ModelProto| { &mut m.self_test_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NormalizerSpec>>(
                    "denormalizer_spec",
                    |m: &ModelProto| { &m.denormalizer_spec },
                    |m: &mut ModelProto| { &mut m.denormalizer_spec },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModelProto>(
                    "ModelProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ModelProto {
        static mut instance: ::protobuf::lazy::Lazy<ModelProto> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ModelProto::new)
        }
    }
}

impl ::protobuf::Clear for ModelProto {
    fn clear(&mut self) {
        self.pieces.clear();
        self.trainer_spec.clear();
        self.normalizer_spec.clear();
        self.self_test_data.clear();
        self.denormalizer_spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModelProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModelProto_SentencePiece {
    // message fields
    piece: ::protobuf::SingularField<::std::string::String>,
    score: ::std::option::Option<f32>,
    field_type: ::std::option::Option<ModelProto_SentencePiece_Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModelProto_SentencePiece {
    fn default() -> &'a ModelProto_SentencePiece {
        <ModelProto_SentencePiece as ::protobuf::Message>::default_instance()
    }
}

impl ModelProto_SentencePiece {
    pub fn new() -> ModelProto_SentencePiece {
        ::std::default::Default::default()
    }

    // optional string piece = 1;


    pub fn get_piece(&self) -> &str {
        match self.piece.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_piece(&mut self) {
        self.piece.clear();
    }

    pub fn has_piece(&self) -> bool {
        self.piece.is_some()
    }

    // Param is passed by value, moved
    pub fn set_piece(&mut self, v: ::std::string::String) {
        self.piece = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_piece(&mut self) -> &mut ::std::string::String {
        if self.piece.is_none() {
            self.piece.set_default();
        }
        self.piece.as_mut().unwrap()
    }

    // Take field
    pub fn take_piece(&mut self) -> ::std::string::String {
        self.piece.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float score = 2;


    pub fn get_score(&self) -> f32 {
        self.score.unwrap_or(0.)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional .sentencepiece.ModelProto.SentencePiece.Type type = 3;


    pub fn get_field_type(&self) -> ModelProto_SentencePiece_Type {
        self.field_type.unwrap_or(ModelProto_SentencePiece_Type::NORMAL)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ModelProto_SentencePiece_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ModelProto_SentencePiece {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.piece)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.piece.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.score {
            my_size += 5;
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.piece.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.score {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(3, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelProto_SentencePiece {
        ModelProto_SentencePiece::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "piece",
                    |m: &ModelProto_SentencePiece| { &m.piece },
                    |m: &mut ModelProto_SentencePiece| { &mut m.piece },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "score",
                    |m: &ModelProto_SentencePiece| { &m.score },
                    |m: &mut ModelProto_SentencePiece| { &mut m.score },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ModelProto_SentencePiece_Type>>(
                    "type",
                    |m: &ModelProto_SentencePiece| { &m.field_type },
                    |m: &mut ModelProto_SentencePiece| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModelProto_SentencePiece>(
                    "ModelProto.SentencePiece",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ModelProto_SentencePiece {
        static mut instance: ::protobuf::lazy::Lazy<ModelProto_SentencePiece> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ModelProto_SentencePiece::new)
        }
    }
}

impl ::protobuf::Clear for ModelProto_SentencePiece {
    fn clear(&mut self) {
        self.piece.clear();
        self.score = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModelProto_SentencePiece {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelProto_SentencePiece {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ModelProto_SentencePiece_Type {
    NORMAL = 1,
    UNKNOWN = 2,
    CONTROL = 3,
    USER_DEFINED = 4,
    BYTE = 6,
    UNUSED = 5,
}

impl ::protobuf::ProtobufEnum for ModelProto_SentencePiece_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ModelProto_SentencePiece_Type> {
        match value {
            1 => ::std::option::Option::Some(ModelProto_SentencePiece_Type::NORMAL),
            2 => ::std::option::Option::Some(ModelProto_SentencePiece_Type::UNKNOWN),
            3 => ::std::option::Option::Some(ModelProto_SentencePiece_Type::CONTROL),
            4 => ::std::option::Option::Some(ModelProto_SentencePiece_Type::USER_DEFINED),
            6 => ::std::option::Option::Some(ModelProto_SentencePiece_Type::BYTE),
            5 => ::std::option::Option::Some(ModelProto_SentencePiece_Type::UNUSED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ModelProto_SentencePiece_Type] = &[
            ModelProto_SentencePiece_Type::NORMAL,
            ModelProto_SentencePiece_Type::UNKNOWN,
            ModelProto_SentencePiece_Type::CONTROL,
            ModelProto_SentencePiece_Type::USER_DEFINED,
            ModelProto_SentencePiece_Type::BYTE,
            ModelProto_SentencePiece_Type::UNUSED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<ModelProto_SentencePiece_Type>("ModelProto.SentencePiece.Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ModelProto_SentencePiece_Type {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ModelProto_SentencePiece_Type {
    fn default() -> Self {
        ModelProto_SentencePiece_Type::NORMAL
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelProto_SentencePiece_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19sentencepiece_model.proto\x12\rsentencepiece\"\xe9\n\n\x0bTrainerS\
    pec\x12\x0f\n\x05input\x18\x01\x20\x03(\tB\0\x12\x16\n\x0cinput_format\
    \x18\x07\x20\x01(\tB\0\x12\x16\n\x0cmodel_prefix\x18\x02\x20\x01(\tB\0\
    \x12C\n\nmodel_type\x18\x03\x20\x01(\x0e2$.sentencepiece.TrainerSpec.Mod\
    elType:\x07UNIGRAMB\0\x12\x1a\n\nvocab_size\x18\x04\x20\x01(\x05:\x04800\
    0B\0\x12\x19\n\x0faccept_language\x18\x05\x20\x03(\tB\0\x12\"\n\x15self_\
    test_sample_size\x18\x06\x20\x01(\x05:\x010B\0\x12$\n\x12character_cover\
    age\x18\n\x20\x01(\x02:\x060.9995B\0\x12\x20\n\x13input_sentence_size\
    \x18\x0b\x20\x01(\x05:\x010B\0\x12&\n\x16shuffle_input_sentence\x18\x13\
    \x20\x01(\x08:\x04trueB\0\x12\x20\n\x14mining_sentence_size\x18\x0c\x20\
    \x01(\x05B\x02\x18\x01\x12\"\n\x16training_sentence_size\x18\r\x20\x01(\
    \x05B\x02\x18\x01\x12*\n\x17seed_sentencepiece_size\x18\x0e\x20\x01(\x05\
    :\x071000000B\0\x12\x20\n\x10shrinking_factor\x18\x0f\x20\x01(\x02:\x040\
    .75B\0\x12#\n\x13max_sentence_length\x18\x12\x20\x01(\x05:\x044192B\0\
    \x12\x19\n\x0bnum_threads\x18\x10\x20\x01(\x05:\x0216B\0\x12\x1f\n\x12nu\
    m_sub_iterations\x18\x11\x20\x01(\x05:\x012B\0\x12&\n\x18max_sentencepie\
    ce_length\x18\x14\x20\x01(\x05:\x0216B\0\x12'\n\x17split_by_unicode_scri\
    pt\x18\x15\x20\x01(\x08:\x04trueB\0\x12\x1f\n\x0fsplit_by_number\x18\x17\
    \x20\x01(\x08:\x04trueB\0\x12#\n\x13split_by_whitespace\x18\x16\x20\x01(\
    \x08:\x04trueB\0\x12+\n\x1atreat_whitespace_as_suffix\x18\x18\x20\x01(\
    \x08:\x05falseB\0\x12\x1d\n\x0csplit_digits\x18\x19\x20\x01(\x08:\x05fal\
    seB\0\x12\x19\n\x0fcontrol_symbols\x18\x1e\x20\x03(\tB\0\x12\x1e\n\x14us\
    er_defined_symbols\x18\x1f\x20\x03(\tB\0\x12\x18\n\x0erequired_chars\x18\
    $\x20\x01(\tB\0\x12\x1e\n\rbyte_fallback\x18#\x20\x01(\x08:\x05falseB\0\
    \x12-\n\x1dvocabulary_output_piece_score\x18\x20\x20\x01(\x08:\x04trueB\
    \0\x12\x20\n\x10hard_vocab_limit\x18!\x20\x01(\x08:\x04trueB\0\x12\x1e\n\
    \ruse_all_vocab\x18\"\x20\x01(\x08:\x05falseB\0\x12\x13\n\x06unk_id\x18(\
    \x20\x01(\x05:\x010B\0\x12\x13\n\x06bos_id\x18)\x20\x01(\x05:\x011B\0\
    \x12\x13\n\x06eos_id\x18*\x20\x01(\x05:\x012B\0\x12\x14\n\x06pad_id\x18+\
    \x20\x01(\x05:\x02-1B\0\x12\x1a\n\tunk_piece\x18-\x20\x01(\t:\x05<unk>B\
    \0\x12\x18\n\tbos_piece\x18.\x20\x01(\t:\x03<s>B\0\x12\x19\n\teos_piece\
    \x18/\x20\x01(\t:\x04</s>B\0\x12\x1a\n\tpad_piece\x180\x20\x01(\t:\x05<p\
    ad>B\0\x12\x1f\n\x0bunk_surface\x18,\x20\x01(\t:\x08\x20\xc3\xa2\xc2\x81\
    \xc2\x87\x20B\0\x12-\n\x1ctrain_extremely_large_corpus\x181\x20\x01(\x08\
    :\x05falseB\0\"7\n\tModelType\x12\x0b\n\x07UNIGRAM\x10\x01\x12\x07\n\x03\
    BPE\x10\x02\x12\x08\n\x04WORD\x10\x03\x12\x08\n\x04CHAR\x10\x04\x1a\0:\0\
    \"\xd4\x01\n\x0eNormalizerSpec\x12\x0e\n\x04name\x18\x01\x20\x01(\tB\0\
    \x12\x1e\n\x14precompiled_charsmap\x18\x02\x20\x01(\x0cB\0\x12\x20\n\x10\
    add_dummy_prefix\x18\x03\x20\x01(\x08:\x04trueB\0\x12(\n\x18remove_extra\
    _whitespaces\x18\x04\x20\x01(\x08:\x04trueB\0\x12\"\n\x12escape_whitespa\
    ces\x18\x05\x20\x01(\x08:\x04trueB\0\x12\x20\n\x16normalization_rule_tsv\
    \x18\x06\x20\x01(\tB\0:\0\"x\n\x0cSelfTestData\x125\n\x07samples\x18\x01\
    \x20\x03(\x0b2\".sentencepiece.SelfTestData.SampleB\0\x1a/\n\x06Sample\
    \x12\x0f\n\x05input\x18\x01\x20\x01(\tB\0\x12\x12\n\x08expected\x18\x02\
    \x20\x01(\tB\0:\0:\0\"\xfe\x03\n\nModelProto\x129\n\x06pieces\x18\x01\
    \x20\x03(\x0b2'.sentencepiece.ModelProto.SentencePieceB\0\x122\n\x0ctrai\
    ner_spec\x18\x02\x20\x01(\x0b2\x1a.sentencepiece.TrainerSpecB\0\x128\n\
    \x0fnormalizer_spec\x18\x03\x20\x01(\x0b2\x1d.sentencepiece.NormalizerSp\
    ecB\0\x125\n\x0eself_test_data\x18\x04\x20\x01(\x0b2\x1b.sentencepiece.S\
    elfTestDataB\0\x12:\n\x11denormalizer_spec\x18\x05\x20\x01(\x0b2\x1d.sen\
    tencepiece.NormalizerSpecB\0\x1a\xd1\x01\n\rSentencePiece\x12\x0f\n\x05p\
    iece\x18\x01\x20\x01(\tB\0\x12\x0f\n\x05score\x18\x02\x20\x01(\x02B\0\
    \x12D\n\x04type\x18\x03\x20\x01(\x0e2,.sentencepiece.ModelProto.Sentence\
    Piece.Type:\x06NORMALB\0\"V\n\x04Type\x12\n\n\x06NORMAL\x10\x01\x12\x0b\
    \n\x07UNKNOWN\x10\x02\x12\x0b\n\x07CONTROL\x10\x03\x12\x10\n\x0cUSER_DEF\
    INED\x10\x04\x12\x08\n\x04BYTE\x10\x06\x12\n\n\x06UNUSED\x10\x05\x1a\0:\
    \0:\0B\0b\x06proto2\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
