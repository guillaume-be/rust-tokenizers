// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `sentencepiece_model.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct TrainerSpec {
    // message fields
    pub input: ::protobuf::RepeatedField<::std::string::String>,
    input_format: ::protobuf::SingularField<::std::string::String>,
    model_prefix: ::protobuf::SingularField<::std::string::String>,
    model_type: ::std::option::Option<TrainerSpec_ModelType>,
    vocab_size: ::std::option::Option<i32>,
    pub accept_language: ::protobuf::RepeatedField<::std::string::String>,
    self_test_sample_size: ::std::option::Option<i32>,
    character_coverage: ::std::option::Option<f32>,
    input_sentence_size: ::std::option::Option<u64>,
    shuffle_input_sentence: ::std::option::Option<bool>,
    mining_sentence_size: ::std::option::Option<i32>,
    training_sentence_size: ::std::option::Option<i32>,
    seed_sentencepiece_size: ::std::option::Option<i32>,
    shrinking_factor: ::std::option::Option<f32>,
    max_sentence_length: ::std::option::Option<i32>,
    num_threads: ::std::option::Option<i32>,
    num_sub_iterations: ::std::option::Option<i32>,
    max_sentencepiece_length: ::std::option::Option<i32>,
    split_by_unicode_script: ::std::option::Option<bool>,
    split_by_number: ::std::option::Option<bool>,
    split_by_whitespace: ::std::option::Option<bool>,
    treat_whitespace_as_suffix: ::std::option::Option<bool>,
    split_digits: ::std::option::Option<bool>,
    pub control_symbols: ::protobuf::RepeatedField<::std::string::String>,
    pub user_defined_symbols: ::protobuf::RepeatedField<::std::string::String>,
    required_chars: ::protobuf::SingularField<::std::string::String>,
    byte_fallback: ::std::option::Option<bool>,
    vocabulary_output_piece_score: ::std::option::Option<bool>,
    hard_vocab_limit: ::std::option::Option<bool>,
    use_all_vocab: ::std::option::Option<bool>,
    unk_id: ::std::option::Option<i32>,
    bos_id: ::std::option::Option<i32>,
    eos_id: ::std::option::Option<i32>,
    pad_id: ::std::option::Option<i32>,
    unk_piece: ::protobuf::SingularField<::std::string::String>,
    bos_piece: ::protobuf::SingularField<::std::string::String>,
    eos_piece: ::protobuf::SingularField<::std::string::String>,
    pad_piece: ::protobuf::SingularField<::std::string::String>,
    unk_surface: ::protobuf::SingularField<::std::string::String>,
    train_extremely_large_corpus: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrainerSpec {
    fn default() -> &'a TrainerSpec {
        <TrainerSpec as ::protobuf::Message>::default_instance()
    }
}

impl TrainerSpec {
    pub fn new() -> TrainerSpec {
        ::std::default::Default::default()
    }

    // repeated string input = 1;


    pub fn get_input(&self) -> &[::std::string::String] {
        &self.input
    }
    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.input = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.input
    }

    // Take field
    pub fn take_input(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.input, ::protobuf::RepeatedField::new())
    }

    // optional string input_format = 7;


    pub fn get_input_format(&self) -> &str {
        match self.input_format.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_input_format(&mut self) {
        self.input_format.clear();
    }

    pub fn has_input_format(&self) -> bool {
        self.input_format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_format(&mut self, v: ::std::string::String) {
        self.input_format = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_format(&mut self) -> &mut ::std::string::String {
        if self.input_format.is_none() {
            self.input_format.set_default();
        }
        self.input_format.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_format(&mut self) -> ::std::string::String {
        self.input_format.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string model_prefix = 2;


    pub fn get_model_prefix(&self) -> &str {
        match self.model_prefix.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_model_prefix(&mut self) {
        self.model_prefix.clear();
    }

    pub fn has_model_prefix(&self) -> bool {
        self.model_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_prefix(&mut self, v: ::std::string::String) {
        self.model_prefix = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_prefix(&mut self) -> &mut ::std::string::String {
        if self.model_prefix.is_none() {
            self.model_prefix.set_default();
        }
        self.model_prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_model_prefix(&mut self) -> ::std::string::String {
        self.model_prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .sentencepiece.TrainerSpec.ModelType model_type = 3;


    pub fn get_model_type(&self) -> TrainerSpec_ModelType {
        self.model_type.unwrap_or(TrainerSpec_ModelType::UNIGRAM)
    }
    pub fn clear_model_type(&mut self) {
        self.model_type = ::std::option::Option::None;
    }

    pub fn has_model_type(&self) -> bool {
        self.model_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_type(&mut self, v: TrainerSpec_ModelType) {
        self.model_type = ::std::option::Option::Some(v);
    }

    // optional int32 vocab_size = 4;


    pub fn get_vocab_size(&self) -> i32 {
        self.vocab_size.unwrap_or(8000i32)
    }
    pub fn clear_vocab_size(&mut self) {
        self.vocab_size = ::std::option::Option::None;
    }

    pub fn has_vocab_size(&self) -> bool {
        self.vocab_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vocab_size(&mut self, v: i32) {
        self.vocab_size = ::std::option::Option::Some(v);
    }

    // repeated string accept_language = 5;


    pub fn get_accept_language(&self) -> &[::std::string::String] {
        &self.accept_language
    }
    pub fn clear_accept_language(&mut self) {
        self.accept_language.clear();
    }

    // Param is passed by value, moved
    pub fn set_accept_language(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.accept_language = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accept_language(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accept_language
    }

    // Take field
    pub fn take_accept_language(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.accept_language, ::protobuf::RepeatedField::new())
    }

    // optional int32 self_test_sample_size = 6;


    pub fn get_self_test_sample_size(&self) -> i32 {
        self.self_test_sample_size.unwrap_or(0i32)
    }
    pub fn clear_self_test_sample_size(&mut self) {
        self.self_test_sample_size = ::std::option::Option::None;
    }

    pub fn has_self_test_sample_size(&self) -> bool {
        self.self_test_sample_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_self_test_sample_size(&mut self, v: i32) {
        self.self_test_sample_size = ::std::option::Option::Some(v);
    }

    // optional float character_coverage = 10;


    pub fn get_character_coverage(&self) -> f32 {
        self.character_coverage.unwrap_or(0.9995f32)
    }
    pub fn clear_character_coverage(&mut self) {
        self.character_coverage = ::std::option::Option::None;
    }

    pub fn has_character_coverage(&self) -> bool {
        self.character_coverage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_character_coverage(&mut self, v: f32) {
        self.character_coverage = ::std::option::Option::Some(v);
    }

    // optional uint64 input_sentence_size = 11;


    pub fn get_input_sentence_size(&self) -> u64 {
        self.input_sentence_size.unwrap_or(0u64)
    }
    pub fn clear_input_sentence_size(&mut self) {
        self.input_sentence_size = ::std::option::Option::None;
    }

    pub fn has_input_sentence_size(&self) -> bool {
        self.input_sentence_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_sentence_size(&mut self, v: u64) {
        self.input_sentence_size = ::std::option::Option::Some(v);
    }

    // optional bool shuffle_input_sentence = 19;


    pub fn get_shuffle_input_sentence(&self) -> bool {
        self.shuffle_input_sentence.unwrap_or(true)
    }
    pub fn clear_shuffle_input_sentence(&mut self) {
        self.shuffle_input_sentence = ::std::option::Option::None;
    }

    pub fn has_shuffle_input_sentence(&self) -> bool {
        self.shuffle_input_sentence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shuffle_input_sentence(&mut self, v: bool) {
        self.shuffle_input_sentence = ::std::option::Option::Some(v);
    }

    // optional int32 mining_sentence_size = 12;


    pub fn get_mining_sentence_size(&self) -> i32 {
        self.mining_sentence_size.unwrap_or(0)
    }
    pub fn clear_mining_sentence_size(&mut self) {
        self.mining_sentence_size = ::std::option::Option::None;
    }

    pub fn has_mining_sentence_size(&self) -> bool {
        self.mining_sentence_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mining_sentence_size(&mut self, v: i32) {
        self.mining_sentence_size = ::std::option::Option::Some(v);
    }

    // optional int32 training_sentence_size = 13;


    pub fn get_training_sentence_size(&self) -> i32 {
        self.training_sentence_size.unwrap_or(0)
    }
    pub fn clear_training_sentence_size(&mut self) {
        self.training_sentence_size = ::std::option::Option::None;
    }

    pub fn has_training_sentence_size(&self) -> bool {
        self.training_sentence_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_training_sentence_size(&mut self, v: i32) {
        self.training_sentence_size = ::std::option::Option::Some(v);
    }

    // optional int32 seed_sentencepiece_size = 14;


    pub fn get_seed_sentencepiece_size(&self) -> i32 {
        self.seed_sentencepiece_size.unwrap_or(1000000i32)
    }
    pub fn clear_seed_sentencepiece_size(&mut self) {
        self.seed_sentencepiece_size = ::std::option::Option::None;
    }

    pub fn has_seed_sentencepiece_size(&self) -> bool {
        self.seed_sentencepiece_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seed_sentencepiece_size(&mut self, v: i32) {
        self.seed_sentencepiece_size = ::std::option::Option::Some(v);
    }

    // optional float shrinking_factor = 15;


    pub fn get_shrinking_factor(&self) -> f32 {
        self.shrinking_factor.unwrap_or(0.75f32)
    }
    pub fn clear_shrinking_factor(&mut self) {
        self.shrinking_factor = ::std::option::Option::None;
    }

    pub fn has_shrinking_factor(&self) -> bool {
        self.shrinking_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shrinking_factor(&mut self, v: f32) {
        self.shrinking_factor = ::std::option::Option::Some(v);
    }

    // optional int32 max_sentence_length = 18;


    pub fn get_max_sentence_length(&self) -> i32 {
        self.max_sentence_length.unwrap_or(4192i32)
    }
    pub fn clear_max_sentence_length(&mut self) {
        self.max_sentence_length = ::std::option::Option::None;
    }

    pub fn has_max_sentence_length(&self) -> bool {
        self.max_sentence_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_sentence_length(&mut self, v: i32) {
        self.max_sentence_length = ::std::option::Option::Some(v);
    }

    // optional int32 num_threads = 16;


    pub fn get_num_threads(&self) -> i32 {
        self.num_threads.unwrap_or(16i32)
    }
    pub fn clear_num_threads(&mut self) {
        self.num_threads = ::std::option::Option::None;
    }

    pub fn has_num_threads(&self) -> bool {
        self.num_threads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_threads(&mut self, v: i32) {
        self.num_threads = ::std::option::Option::Some(v);
    }

    // optional int32 num_sub_iterations = 17;


    pub fn get_num_sub_iterations(&self) -> i32 {
        self.num_sub_iterations.unwrap_or(2i32)
    }
    pub fn clear_num_sub_iterations(&mut self) {
        self.num_sub_iterations = ::std::option::Option::None;
    }

    pub fn has_num_sub_iterations(&self) -> bool {
        self.num_sub_iterations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_sub_iterations(&mut self, v: i32) {
        self.num_sub_iterations = ::std::option::Option::Some(v);
    }

    // optional int32 max_sentencepiece_length = 20;


    pub fn get_max_sentencepiece_length(&self) -> i32 {
        self.max_sentencepiece_length.unwrap_or(16i32)
    }
    pub fn clear_max_sentencepiece_length(&mut self) {
        self.max_sentencepiece_length = ::std::option::Option::None;
    }

    pub fn has_max_sentencepiece_length(&self) -> bool {
        self.max_sentencepiece_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_sentencepiece_length(&mut self, v: i32) {
        self.max_sentencepiece_length = ::std::option::Option::Some(v);
    }

    // optional bool split_by_unicode_script = 21;


    pub fn get_split_by_unicode_script(&self) -> bool {
        self.split_by_unicode_script.unwrap_or(true)
    }
    pub fn clear_split_by_unicode_script(&mut self) {
        self.split_by_unicode_script = ::std::option::Option::None;
    }

    pub fn has_split_by_unicode_script(&self) -> bool {
        self.split_by_unicode_script.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_by_unicode_script(&mut self, v: bool) {
        self.split_by_unicode_script = ::std::option::Option::Some(v);
    }

    // optional bool split_by_number = 23;


    pub fn get_split_by_number(&self) -> bool {
        self.split_by_number.unwrap_or(true)
    }
    pub fn clear_split_by_number(&mut self) {
        self.split_by_number = ::std::option::Option::None;
    }

    pub fn has_split_by_number(&self) -> bool {
        self.split_by_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_by_number(&mut self, v: bool) {
        self.split_by_number = ::std::option::Option::Some(v);
    }

    // optional bool split_by_whitespace = 22;


    pub fn get_split_by_whitespace(&self) -> bool {
        self.split_by_whitespace.unwrap_or(true)
    }
    pub fn clear_split_by_whitespace(&mut self) {
        self.split_by_whitespace = ::std::option::Option::None;
    }

    pub fn has_split_by_whitespace(&self) -> bool {
        self.split_by_whitespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_by_whitespace(&mut self, v: bool) {
        self.split_by_whitespace = ::std::option::Option::Some(v);
    }

    // optional bool treat_whitespace_as_suffix = 24;


    pub fn get_treat_whitespace_as_suffix(&self) -> bool {
        self.treat_whitespace_as_suffix.unwrap_or(false)
    }
    pub fn clear_treat_whitespace_as_suffix(&mut self) {
        self.treat_whitespace_as_suffix = ::std::option::Option::None;
    }

    pub fn has_treat_whitespace_as_suffix(&self) -> bool {
        self.treat_whitespace_as_suffix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_treat_whitespace_as_suffix(&mut self, v: bool) {
        self.treat_whitespace_as_suffix = ::std::option::Option::Some(v);
    }

    // optional bool split_digits = 25;


    pub fn get_split_digits(&self) -> bool {
        self.split_digits.unwrap_or(false)
    }
    pub fn clear_split_digits(&mut self) {
        self.split_digits = ::std::option::Option::None;
    }

    pub fn has_split_digits(&self) -> bool {
        self.split_digits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_digits(&mut self, v: bool) {
        self.split_digits = ::std::option::Option::Some(v);
    }

    // repeated string control_symbols = 30;


    pub fn get_control_symbols(&self) -> &[::std::string::String] {
        &self.control_symbols
    }
    pub fn clear_control_symbols(&mut self) {
        self.control_symbols.clear();
    }

    // Param is passed by value, moved
    pub fn set_control_symbols(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.control_symbols = v;
    }

    // Mutable pointer to the field.
    pub fn mut_control_symbols(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.control_symbols
    }

    // Take field
    pub fn take_control_symbols(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.control_symbols, ::protobuf::RepeatedField::new())
    }

    // repeated string user_defined_symbols = 31;


    pub fn get_user_defined_symbols(&self) -> &[::std::string::String] {
        &self.user_defined_symbols
    }
    pub fn clear_user_defined_symbols(&mut self) {
        self.user_defined_symbols.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_defined_symbols(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_defined_symbols = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_defined_symbols(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_defined_symbols
    }

    // Take field
    pub fn take_user_defined_symbols(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_defined_symbols, ::protobuf::RepeatedField::new())
    }

    // optional string required_chars = 36;


    pub fn get_required_chars(&self) -> &str {
        match self.required_chars.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_required_chars(&mut self) {
        self.required_chars.clear();
    }

    pub fn has_required_chars(&self) -> bool {
        self.required_chars.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_chars(&mut self, v: ::std::string::String) {
        self.required_chars = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_required_chars(&mut self) -> &mut ::std::string::String {
        if self.required_chars.is_none() {
            self.required_chars.set_default();
        }
        self.required_chars.as_mut().unwrap()
    }

    // Take field
    pub fn take_required_chars(&mut self) -> ::std::string::String {
        self.required_chars.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool byte_fallback = 35;


    pub fn get_byte_fallback(&self) -> bool {
        self.byte_fallback.unwrap_or(false)
    }
    pub fn clear_byte_fallback(&mut self) {
        self.byte_fallback = ::std::option::Option::None;
    }

    pub fn has_byte_fallback(&self) -> bool {
        self.byte_fallback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_byte_fallback(&mut self, v: bool) {
        self.byte_fallback = ::std::option::Option::Some(v);
    }

    // optional bool vocabulary_output_piece_score = 32;


    pub fn get_vocabulary_output_piece_score(&self) -> bool {
        self.vocabulary_output_piece_score.unwrap_or(true)
    }
    pub fn clear_vocabulary_output_piece_score(&mut self) {
        self.vocabulary_output_piece_score = ::std::option::Option::None;
    }

    pub fn has_vocabulary_output_piece_score(&self) -> bool {
        self.vocabulary_output_piece_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vocabulary_output_piece_score(&mut self, v: bool) {
        self.vocabulary_output_piece_score = ::std::option::Option::Some(v);
    }

    // optional bool hard_vocab_limit = 33;


    pub fn get_hard_vocab_limit(&self) -> bool {
        self.hard_vocab_limit.unwrap_or(true)
    }
    pub fn clear_hard_vocab_limit(&mut self) {
        self.hard_vocab_limit = ::std::option::Option::None;
    }

    pub fn has_hard_vocab_limit(&self) -> bool {
        self.hard_vocab_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hard_vocab_limit(&mut self, v: bool) {
        self.hard_vocab_limit = ::std::option::Option::Some(v);
    }

    // optional bool use_all_vocab = 34;


    pub fn get_use_all_vocab(&self) -> bool {
        self.use_all_vocab.unwrap_or(false)
    }
    pub fn clear_use_all_vocab(&mut self) {
        self.use_all_vocab = ::std::option::Option::None;
    }

    pub fn has_use_all_vocab(&self) -> bool {
        self.use_all_vocab.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_all_vocab(&mut self, v: bool) {
        self.use_all_vocab = ::std::option::Option::Some(v);
    }

    // optional int32 unk_id = 40;


    pub fn get_unk_id(&self) -> i32 {
        self.unk_id.unwrap_or(0i32)
    }
    pub fn clear_unk_id(&mut self) {
        self.unk_id = ::std::option::Option::None;
    }

    pub fn has_unk_id(&self) -> bool {
        self.unk_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unk_id(&mut self, v: i32) {
        self.unk_id = ::std::option::Option::Some(v);
    }

    // optional int32 bos_id = 41;


    pub fn get_bos_id(&self) -> i32 {
        self.bos_id.unwrap_or(1i32)
    }
    pub fn clear_bos_id(&mut self) {
        self.bos_id = ::std::option::Option::None;
    }

    pub fn has_bos_id(&self) -> bool {
        self.bos_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bos_id(&mut self, v: i32) {
        self.bos_id = ::std::option::Option::Some(v);
    }

    // optional int32 eos_id = 42;


    pub fn get_eos_id(&self) -> i32 {
        self.eos_id.unwrap_or(2i32)
    }
    pub fn clear_eos_id(&mut self) {
        self.eos_id = ::std::option::Option::None;
    }

    pub fn has_eos_id(&self) -> bool {
        self.eos_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eos_id(&mut self, v: i32) {
        self.eos_id = ::std::option::Option::Some(v);
    }

    // optional int32 pad_id = 43;


    pub fn get_pad_id(&self) -> i32 {
        self.pad_id.unwrap_or(-1i32)
    }
    pub fn clear_pad_id(&mut self) {
        self.pad_id = ::std::option::Option::None;
    }

    pub fn has_pad_id(&self) -> bool {
        self.pad_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pad_id(&mut self, v: i32) {
        self.pad_id = ::std::option::Option::Some(v);
    }

    // optional string unk_piece = 45;


    pub fn get_unk_piece(&self) -> &str {
        match self.unk_piece.as_ref() {
            Some(v) => &v,
            None => "<unk>",
        }
    }
    pub fn clear_unk_piece(&mut self) {
        self.unk_piece.clear();
    }

    pub fn has_unk_piece(&self) -> bool {
        self.unk_piece.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unk_piece(&mut self, v: ::std::string::String) {
        self.unk_piece = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unk_piece(&mut self) -> &mut ::std::string::String {
        if self.unk_piece.is_none() {
            self.unk_piece.set_default();
        }
        self.unk_piece.as_mut().unwrap()
    }

    // Take field
    pub fn take_unk_piece(&mut self) -> ::std::string::String {
        self.unk_piece.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bos_piece = 46;


    pub fn get_bos_piece(&self) -> &str {
        match self.bos_piece.as_ref() {
            Some(v) => &v,
            None => "<s>",
        }
    }
    pub fn clear_bos_piece(&mut self) {
        self.bos_piece.clear();
    }

    pub fn has_bos_piece(&self) -> bool {
        self.bos_piece.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bos_piece(&mut self, v: ::std::string::String) {
        self.bos_piece = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bos_piece(&mut self) -> &mut ::std::string::String {
        if self.bos_piece.is_none() {
            self.bos_piece.set_default();
        }
        self.bos_piece.as_mut().unwrap()
    }

    // Take field
    pub fn take_bos_piece(&mut self) -> ::std::string::String {
        self.bos_piece.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string eos_piece = 47;


    pub fn get_eos_piece(&self) -> &str {
        match self.eos_piece.as_ref() {
            Some(v) => &v,
            None => "</s>",
        }
    }
    pub fn clear_eos_piece(&mut self) {
        self.eos_piece.clear();
    }

    pub fn has_eos_piece(&self) -> bool {
        self.eos_piece.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eos_piece(&mut self, v: ::std::string::String) {
        self.eos_piece = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eos_piece(&mut self) -> &mut ::std::string::String {
        if self.eos_piece.is_none() {
            self.eos_piece.set_default();
        }
        self.eos_piece.as_mut().unwrap()
    }

    // Take field
    pub fn take_eos_piece(&mut self) -> ::std::string::String {
        self.eos_piece.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pad_piece = 48;


    pub fn get_pad_piece(&self) -> &str {
        match self.pad_piece.as_ref() {
            Some(v) => &v,
            None => "<pad>",
        }
    }
    pub fn clear_pad_piece(&mut self) {
        self.pad_piece.clear();
    }

    pub fn has_pad_piece(&self) -> bool {
        self.pad_piece.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pad_piece(&mut self, v: ::std::string::String) {
        self.pad_piece = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pad_piece(&mut self) -> &mut ::std::string::String {
        if self.pad_piece.is_none() {
            self.pad_piece.set_default();
        }
        self.pad_piece.as_mut().unwrap()
    }

    // Take field
    pub fn take_pad_piece(&mut self) -> ::std::string::String {
        self.pad_piece.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string unk_surface = 44;


    pub fn get_unk_surface(&self) -> &str {
        match self.unk_surface.as_ref() {
            Some(v) => &v,
            None => " \u{2047} ",
        }
    }
    pub fn clear_unk_surface(&mut self) {
        self.unk_surface.clear();
    }

    pub fn has_unk_surface(&self) -> bool {
        self.unk_surface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unk_surface(&mut self, v: ::std::string::String) {
        self.unk_surface = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unk_surface(&mut self) -> &mut ::std::string::String {
        if self.unk_surface.is_none() {
            self.unk_surface.set_default();
        }
        self.unk_surface.as_mut().unwrap()
    }

    // Take field
    pub fn take_unk_surface(&mut self) -> ::std::string::String {
        self.unk_surface.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool train_extremely_large_corpus = 49;


    pub fn get_train_extremely_large_corpus(&self) -> bool {
        self.train_extremely_large_corpus.unwrap_or(false)
    }
    pub fn clear_train_extremely_large_corpus(&mut self) {
        self.train_extremely_large_corpus = ::std::option::Option::None;
    }

    pub fn has_train_extremely_large_corpus(&self) -> bool {
        self.train_extremely_large_corpus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_train_extremely_large_corpus(&mut self, v: bool) {
        self.train_extremely_large_corpus = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TrainerSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.input)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.input_format)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.model_prefix)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.model_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.vocab_size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.accept_language)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.self_test_sample_size = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.character_coverage = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.input_sentence_size = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.shuffle_input_sentence = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mining_sentence_size = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.training_sentence_size = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seed_sentencepiece_size = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.shrinking_factor = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_sentence_length = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_threads = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_sub_iterations = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_sentencepiece_length = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.split_by_unicode_script = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.split_by_number = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.split_by_whitespace = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.treat_whitespace_as_suffix = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.split_digits = ::std::option::Option::Some(tmp);
                },
                30 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.control_symbols)?;
                },
                31 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_defined_symbols)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.required_chars)?;
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.byte_fallback = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.vocabulary_output_piece_score = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hard_vocab_limit = ::std::option::Option::Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_all_vocab = ::std::option::Option::Some(tmp);
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unk_id = ::std::option::Option::Some(tmp);
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bos_id = ::std::option::Option::Some(tmp);
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eos_id = ::std::option::Option::Some(tmp);
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pad_id = ::std::option::Option::Some(tmp);
                },
                45 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.unk_piece)?;
                },
                46 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bos_piece)?;
                },
                47 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.eos_piece)?;
                },
                48 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pad_piece)?;
                },
                44 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.unk_surface)?;
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.train_extremely_large_corpus = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.input {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.input_format.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.model_prefix.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.model_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.vocab_size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.accept_language {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.self_test_sample_size {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.character_coverage {
            my_size += 5;
        }
        if let Some(v) = self.input_sentence_size {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shuffle_input_sentence {
            my_size += 3;
        }
        if let Some(v) = self.mining_sentence_size {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.training_sentence_size {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seed_sentencepiece_size {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shrinking_factor {
            my_size += 5;
        }
        if let Some(v) = self.max_sentence_length {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_threads {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_sub_iterations {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_sentencepiece_length {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.split_by_unicode_script {
            my_size += 3;
        }
        if let Some(v) = self.split_by_number {
            my_size += 3;
        }
        if let Some(v) = self.split_by_whitespace {
            my_size += 3;
        }
        if let Some(v) = self.treat_whitespace_as_suffix {
            my_size += 3;
        }
        if let Some(v) = self.split_digits {
            my_size += 3;
        }
        for value in &self.control_symbols {
            my_size += ::protobuf::rt::string_size(30, &value);
        };
        for value in &self.user_defined_symbols {
            my_size += ::protobuf::rt::string_size(31, &value);
        };
        if let Some(ref v) = self.required_chars.as_ref() {
            my_size += ::protobuf::rt::string_size(36, &v);
        }
        if let Some(v) = self.byte_fallback {
            my_size += 3;
        }
        if let Some(v) = self.vocabulary_output_piece_score {
            my_size += 3;
        }
        if let Some(v) = self.hard_vocab_limit {
            my_size += 3;
        }
        if let Some(v) = self.use_all_vocab {
            my_size += 3;
        }
        if let Some(v) = self.unk_id {
            my_size += ::protobuf::rt::value_size(40, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bos_id {
            my_size += ::protobuf::rt::value_size(41, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.eos_id {
            my_size += ::protobuf::rt::value_size(42, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pad_id {
            my_size += ::protobuf::rt::value_size(43, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.unk_piece.as_ref() {
            my_size += ::protobuf::rt::string_size(45, &v);
        }
        if let Some(ref v) = self.bos_piece.as_ref() {
            my_size += ::protobuf::rt::string_size(46, &v);
        }
        if let Some(ref v) = self.eos_piece.as_ref() {
            my_size += ::protobuf::rt::string_size(47, &v);
        }
        if let Some(ref v) = self.pad_piece.as_ref() {
            my_size += ::protobuf::rt::string_size(48, &v);
        }
        if let Some(ref v) = self.unk_surface.as_ref() {
            my_size += ::protobuf::rt::string_size(44, &v);
        }
        if let Some(v) = self.train_extremely_large_corpus {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.input {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.input_format.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.model_prefix.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.model_type {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.vocab_size {
            os.write_int32(4, v)?;
        }
        for v in &self.accept_language {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.self_test_sample_size {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.character_coverage {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.input_sentence_size {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.shuffle_input_sentence {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.mining_sentence_size {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.training_sentence_size {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.seed_sentencepiece_size {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.shrinking_factor {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.max_sentence_length {
            os.write_int32(18, v)?;
        }
        if let Some(v) = self.num_threads {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.num_sub_iterations {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.max_sentencepiece_length {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.split_by_unicode_script {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.split_by_number {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.split_by_whitespace {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.treat_whitespace_as_suffix {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.split_digits {
            os.write_bool(25, v)?;
        }
        for v in &self.control_symbols {
            os.write_string(30, &v)?;
        };
        for v in &self.user_defined_symbols {
            os.write_string(31, &v)?;
        };
        if let Some(ref v) = self.required_chars.as_ref() {
            os.write_string(36, &v)?;
        }
        if let Some(v) = self.byte_fallback {
            os.write_bool(35, v)?;
        }
        if let Some(v) = self.vocabulary_output_piece_score {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.hard_vocab_limit {
            os.write_bool(33, v)?;
        }
        if let Some(v) = self.use_all_vocab {
            os.write_bool(34, v)?;
        }
        if let Some(v) = self.unk_id {
            os.write_int32(40, v)?;
        }
        if let Some(v) = self.bos_id {
            os.write_int32(41, v)?;
        }
        if let Some(v) = self.eos_id {
            os.write_int32(42, v)?;
        }
        if let Some(v) = self.pad_id {
            os.write_int32(43, v)?;
        }
        if let Some(ref v) = self.unk_piece.as_ref() {
            os.write_string(45, &v)?;
        }
        if let Some(ref v) = self.bos_piece.as_ref() {
            os.write_string(46, &v)?;
        }
        if let Some(ref v) = self.eos_piece.as_ref() {
            os.write_string(47, &v)?;
        }
        if let Some(ref v) = self.pad_piece.as_ref() {
            os.write_string(48, &v)?;
        }
        if let Some(ref v) = self.unk_surface.as_ref() {
            os.write_string(44, &v)?;
        }
        if let Some(v) = self.train_extremely_large_corpus {
            os.write_bool(49, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrainerSpec {
        TrainerSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input",
                |m: &TrainerSpec| { &m.input },
                |m: &mut TrainerSpec| { &mut m.input },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input_format",
                |m: &TrainerSpec| { &m.input_format },
                |m: &mut TrainerSpec| { &mut m.input_format },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_prefix",
                |m: &TrainerSpec| { &m.model_prefix },
                |m: &mut TrainerSpec| { &mut m.model_prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TrainerSpec_ModelType>>(
                "model_type",
                |m: &TrainerSpec| { &m.model_type },
                |m: &mut TrainerSpec| { &mut m.model_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "vocab_size",
                |m: &TrainerSpec| { &m.vocab_size },
                |m: &mut TrainerSpec| { &mut m.vocab_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accept_language",
                |m: &TrainerSpec| { &m.accept_language },
                |m: &mut TrainerSpec| { &mut m.accept_language },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "self_test_sample_size",
                |m: &TrainerSpec| { &m.self_test_sample_size },
                |m: &mut TrainerSpec| { &mut m.self_test_sample_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "character_coverage",
                |m: &TrainerSpec| { &m.character_coverage },
                |m: &mut TrainerSpec| { &mut m.character_coverage },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "input_sentence_size",
                |m: &TrainerSpec| { &m.input_sentence_size },
                |m: &mut TrainerSpec| { &mut m.input_sentence_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "shuffle_input_sentence",
                |m: &TrainerSpec| { &m.shuffle_input_sentence },
                |m: &mut TrainerSpec| { &mut m.shuffle_input_sentence },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mining_sentence_size",
                |m: &TrainerSpec| { &m.mining_sentence_size },
                |m: &mut TrainerSpec| { &mut m.mining_sentence_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "training_sentence_size",
                |m: &TrainerSpec| { &m.training_sentence_size },
                |m: &mut TrainerSpec| { &mut m.training_sentence_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seed_sentencepiece_size",
                |m: &TrainerSpec| { &m.seed_sentencepiece_size },
                |m: &mut TrainerSpec| { &mut m.seed_sentencepiece_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "shrinking_factor",
                |m: &TrainerSpec| { &m.shrinking_factor },
                |m: &mut TrainerSpec| { &mut m.shrinking_factor },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_sentence_length",
                |m: &TrainerSpec| { &m.max_sentence_length },
                |m: &mut TrainerSpec| { &mut m.max_sentence_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_threads",
                |m: &TrainerSpec| { &m.num_threads },
                |m: &mut TrainerSpec| { &mut m.num_threads },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_sub_iterations",
                |m: &TrainerSpec| { &m.num_sub_iterations },
                |m: &mut TrainerSpec| { &mut m.num_sub_iterations },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_sentencepiece_length",
                |m: &TrainerSpec| { &m.max_sentencepiece_length },
                |m: &mut TrainerSpec| { &mut m.max_sentencepiece_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "split_by_unicode_script",
                |m: &TrainerSpec| { &m.split_by_unicode_script },
                |m: &mut TrainerSpec| { &mut m.split_by_unicode_script },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "split_by_number",
                |m: &TrainerSpec| { &m.split_by_number },
                |m: &mut TrainerSpec| { &mut m.split_by_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "split_by_whitespace",
                |m: &TrainerSpec| { &m.split_by_whitespace },
                |m: &mut TrainerSpec| { &mut m.split_by_whitespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "treat_whitespace_as_suffix",
                |m: &TrainerSpec| { &m.treat_whitespace_as_suffix },
                |m: &mut TrainerSpec| { &mut m.treat_whitespace_as_suffix },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "split_digits",
                |m: &TrainerSpec| { &m.split_digits },
                |m: &mut TrainerSpec| { &mut m.split_digits },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "control_symbols",
                |m: &TrainerSpec| { &m.control_symbols },
                |m: &mut TrainerSpec| { &mut m.control_symbols },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_defined_symbols",
                |m: &TrainerSpec| { &m.user_defined_symbols },
                |m: &mut TrainerSpec| { &mut m.user_defined_symbols },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "required_chars",
                |m: &TrainerSpec| { &m.required_chars },
                |m: &mut TrainerSpec| { &mut m.required_chars },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "byte_fallback",
                |m: &TrainerSpec| { &m.byte_fallback },
                |m: &mut TrainerSpec| { &mut m.byte_fallback },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "vocabulary_output_piece_score",
                |m: &TrainerSpec| { &m.vocabulary_output_piece_score },
                |m: &mut TrainerSpec| { &mut m.vocabulary_output_piece_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hard_vocab_limit",
                |m: &TrainerSpec| { &m.hard_vocab_limit },
                |m: &mut TrainerSpec| { &mut m.hard_vocab_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_all_vocab",
                |m: &TrainerSpec| { &m.use_all_vocab },
                |m: &mut TrainerSpec| { &mut m.use_all_vocab },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unk_id",
                |m: &TrainerSpec| { &m.unk_id },
                |m: &mut TrainerSpec| { &mut m.unk_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bos_id",
                |m: &TrainerSpec| { &m.bos_id },
                |m: &mut TrainerSpec| { &mut m.bos_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eos_id",
                |m: &TrainerSpec| { &m.eos_id },
                |m: &mut TrainerSpec| { &mut m.eos_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pad_id",
                |m: &TrainerSpec| { &m.pad_id },
                |m: &mut TrainerSpec| { &mut m.pad_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unk_piece",
                |m: &TrainerSpec| { &m.unk_piece },
                |m: &mut TrainerSpec| { &mut m.unk_piece },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bos_piece",
                |m: &TrainerSpec| { &m.bos_piece },
                |m: &mut TrainerSpec| { &mut m.bos_piece },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "eos_piece",
                |m: &TrainerSpec| { &m.eos_piece },
                |m: &mut TrainerSpec| { &mut m.eos_piece },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pad_piece",
                |m: &TrainerSpec| { &m.pad_piece },
                |m: &mut TrainerSpec| { &mut m.pad_piece },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unk_surface",
                |m: &TrainerSpec| { &m.unk_surface },
                |m: &mut TrainerSpec| { &mut m.unk_surface },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "train_extremely_large_corpus",
                |m: &TrainerSpec| { &m.train_extremely_large_corpus },
                |m: &mut TrainerSpec| { &mut m.train_extremely_large_corpus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrainerSpec>(
                "TrainerSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrainerSpec {
        static instance: ::protobuf::rt::LazyV2<TrainerSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrainerSpec::new)
    }
}

impl ::protobuf::Clear for TrainerSpec {
    fn clear(&mut self) {
        self.input.clear();
        self.input_format.clear();
        self.model_prefix.clear();
        self.model_type = ::std::option::Option::None;
        self.vocab_size = ::std::option::Option::None;
        self.accept_language.clear();
        self.self_test_sample_size = ::std::option::Option::None;
        self.character_coverage = ::std::option::Option::None;
        self.input_sentence_size = ::std::option::Option::None;
        self.shuffle_input_sentence = ::std::option::Option::None;
        self.mining_sentence_size = ::std::option::Option::None;
        self.training_sentence_size = ::std::option::Option::None;
        self.seed_sentencepiece_size = ::std::option::Option::None;
        self.shrinking_factor = ::std::option::Option::None;
        self.max_sentence_length = ::std::option::Option::None;
        self.num_threads = ::std::option::Option::None;
        self.num_sub_iterations = ::std::option::Option::None;
        self.max_sentencepiece_length = ::std::option::Option::None;
        self.split_by_unicode_script = ::std::option::Option::None;
        self.split_by_number = ::std::option::Option::None;
        self.split_by_whitespace = ::std::option::Option::None;
        self.treat_whitespace_as_suffix = ::std::option::Option::None;
        self.split_digits = ::std::option::Option::None;
        self.control_symbols.clear();
        self.user_defined_symbols.clear();
        self.required_chars.clear();
        self.byte_fallback = ::std::option::Option::None;
        self.vocabulary_output_piece_score = ::std::option::Option::None;
        self.hard_vocab_limit = ::std::option::Option::None;
        self.use_all_vocab = ::std::option::Option::None;
        self.unk_id = ::std::option::Option::None;
        self.bos_id = ::std::option::Option::None;
        self.eos_id = ::std::option::Option::None;
        self.pad_id = ::std::option::Option::None;
        self.unk_piece.clear();
        self.bos_piece.clear();
        self.eos_piece.clear();
        self.pad_piece.clear();
        self.unk_surface.clear();
        self.train_extremely_large_corpus = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrainerSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainerSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TrainerSpec_ModelType {
    UNIGRAM = 1,
    BPE = 2,
    WORD = 3,
    CHAR = 4,
}

impl ::protobuf::ProtobufEnum for TrainerSpec_ModelType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TrainerSpec_ModelType> {
        match value {
            1 => ::std::option::Option::Some(TrainerSpec_ModelType::UNIGRAM),
            2 => ::std::option::Option::Some(TrainerSpec_ModelType::BPE),
            3 => ::std::option::Option::Some(TrainerSpec_ModelType::WORD),
            4 => ::std::option::Option::Some(TrainerSpec_ModelType::CHAR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TrainerSpec_ModelType] = &[
            TrainerSpec_ModelType::UNIGRAM,
            TrainerSpec_ModelType::BPE,
            TrainerSpec_ModelType::WORD,
            TrainerSpec_ModelType::CHAR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TrainerSpec_ModelType>("TrainerSpec.ModelType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TrainerSpec_ModelType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TrainerSpec_ModelType {
    fn default() -> Self {
        TrainerSpec_ModelType::UNIGRAM
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainerSpec_ModelType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NormalizerSpec {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    precompiled_charsmap: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    add_dummy_prefix: ::std::option::Option<bool>,
    remove_extra_whitespaces: ::std::option::Option<bool>,
    escape_whitespaces: ::std::option::Option<bool>,
    normalization_rule_tsv: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NormalizerSpec {
    fn default() -> &'a NormalizerSpec {
        <NormalizerSpec as ::protobuf::Message>::default_instance()
    }
}

impl NormalizerSpec {
    pub fn new() -> NormalizerSpec {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes precompiled_charsmap = 2;


    pub fn get_precompiled_charsmap(&self) -> &[u8] {
        match self.precompiled_charsmap.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_precompiled_charsmap(&mut self) {
        self.precompiled_charsmap.clear();
    }

    pub fn has_precompiled_charsmap(&self) -> bool {
        self.precompiled_charsmap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_precompiled_charsmap(&mut self, v: ::std::vec::Vec<u8>) {
        self.precompiled_charsmap = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_precompiled_charsmap(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.precompiled_charsmap.is_none() {
            self.precompiled_charsmap.set_default();
        }
        self.precompiled_charsmap.as_mut().unwrap()
    }

    // Take field
    pub fn take_precompiled_charsmap(&mut self) -> ::std::vec::Vec<u8> {
        self.precompiled_charsmap.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool add_dummy_prefix = 3;


    pub fn get_add_dummy_prefix(&self) -> bool {
        self.add_dummy_prefix.unwrap_or(true)
    }
    pub fn clear_add_dummy_prefix(&mut self) {
        self.add_dummy_prefix = ::std::option::Option::None;
    }

    pub fn has_add_dummy_prefix(&self) -> bool {
        self.add_dummy_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_dummy_prefix(&mut self, v: bool) {
        self.add_dummy_prefix = ::std::option::Option::Some(v);
    }

    // optional bool remove_extra_whitespaces = 4;


    pub fn get_remove_extra_whitespaces(&self) -> bool {
        self.remove_extra_whitespaces.unwrap_or(true)
    }
    pub fn clear_remove_extra_whitespaces(&mut self) {
        self.remove_extra_whitespaces = ::std::option::Option::None;
    }

    pub fn has_remove_extra_whitespaces(&self) -> bool {
        self.remove_extra_whitespaces.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove_extra_whitespaces(&mut self, v: bool) {
        self.remove_extra_whitespaces = ::std::option::Option::Some(v);
    }

    // optional bool escape_whitespaces = 5;


    pub fn get_escape_whitespaces(&self) -> bool {
        self.escape_whitespaces.unwrap_or(true)
    }
    pub fn clear_escape_whitespaces(&mut self) {
        self.escape_whitespaces = ::std::option::Option::None;
    }

    pub fn has_escape_whitespaces(&self) -> bool {
        self.escape_whitespaces.is_some()
    }

    // Param is passed by value, moved
    pub fn set_escape_whitespaces(&mut self, v: bool) {
        self.escape_whitespaces = ::std::option::Option::Some(v);
    }

    // optional string normalization_rule_tsv = 6;


    pub fn get_normalization_rule_tsv(&self) -> &str {
        match self.normalization_rule_tsv.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_normalization_rule_tsv(&mut self) {
        self.normalization_rule_tsv.clear();
    }

    pub fn has_normalization_rule_tsv(&self) -> bool {
        self.normalization_rule_tsv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normalization_rule_tsv(&mut self, v: ::std::string::String) {
        self.normalization_rule_tsv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_normalization_rule_tsv(&mut self) -> &mut ::std::string::String {
        if self.normalization_rule_tsv.is_none() {
            self.normalization_rule_tsv.set_default();
        }
        self.normalization_rule_tsv.as_mut().unwrap()
    }

    // Take field
    pub fn take_normalization_rule_tsv(&mut self) -> ::std::string::String {
        self.normalization_rule_tsv.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for NormalizerSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.precompiled_charsmap)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.add_dummy_prefix = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remove_extra_whitespaces = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.escape_whitespaces = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.normalization_rule_tsv)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.precompiled_charsmap.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.add_dummy_prefix {
            my_size += 2;
        }
        if let Some(v) = self.remove_extra_whitespaces {
            my_size += 2;
        }
        if let Some(v) = self.escape_whitespaces {
            my_size += 2;
        }
        if let Some(ref v) = self.normalization_rule_tsv.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.precompiled_charsmap.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.add_dummy_prefix {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.remove_extra_whitespaces {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.escape_whitespaces {
            os.write_bool(5, v)?;
        }
        if let Some(ref v) = self.normalization_rule_tsv.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NormalizerSpec {
        NormalizerSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &NormalizerSpec| { &m.name },
                |m: &mut NormalizerSpec| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "precompiled_charsmap",
                |m: &NormalizerSpec| { &m.precompiled_charsmap },
                |m: &mut NormalizerSpec| { &mut m.precompiled_charsmap },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "add_dummy_prefix",
                |m: &NormalizerSpec| { &m.add_dummy_prefix },
                |m: &mut NormalizerSpec| { &mut m.add_dummy_prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "remove_extra_whitespaces",
                |m: &NormalizerSpec| { &m.remove_extra_whitespaces },
                |m: &mut NormalizerSpec| { &mut m.remove_extra_whitespaces },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "escape_whitespaces",
                |m: &NormalizerSpec| { &m.escape_whitespaces },
                |m: &mut NormalizerSpec| { &mut m.escape_whitespaces },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "normalization_rule_tsv",
                |m: &NormalizerSpec| { &m.normalization_rule_tsv },
                |m: &mut NormalizerSpec| { &mut m.normalization_rule_tsv },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NormalizerSpec>(
                "NormalizerSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NormalizerSpec {
        static instance: ::protobuf::rt::LazyV2<NormalizerSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NormalizerSpec::new)
    }
}

impl ::protobuf::Clear for NormalizerSpec {
    fn clear(&mut self) {
        self.name.clear();
        self.precompiled_charsmap.clear();
        self.add_dummy_prefix = ::std::option::Option::None;
        self.remove_extra_whitespaces = ::std::option::Option::None;
        self.escape_whitespaces = ::std::option::Option::None;
        self.normalization_rule_tsv.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NormalizerSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NormalizerSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SelfTestData {
    // message fields
    pub samples: ::protobuf::RepeatedField<SelfTestData_Sample>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SelfTestData {
    fn default() -> &'a SelfTestData {
        <SelfTestData as ::protobuf::Message>::default_instance()
    }
}

impl SelfTestData {
    pub fn new() -> SelfTestData {
        ::std::default::Default::default()
    }

    // repeated .sentencepiece.SelfTestData.Sample samples = 1;


    pub fn get_samples(&self) -> &[SelfTestData_Sample] {
        &self.samples
    }
    pub fn clear_samples(&mut self) {
        self.samples.clear();
    }

    // Param is passed by value, moved
    pub fn set_samples(&mut self, v: ::protobuf::RepeatedField<SelfTestData_Sample>) {
        self.samples = v;
    }

    // Mutable pointer to the field.
    pub fn mut_samples(&mut self) -> &mut ::protobuf::RepeatedField<SelfTestData_Sample> {
        &mut self.samples
    }

    // Take field
    pub fn take_samples(&mut self) -> ::protobuf::RepeatedField<SelfTestData_Sample> {
        ::std::mem::replace(&mut self.samples, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SelfTestData {
    fn is_initialized(&self) -> bool {
        for v in &self.samples {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.samples)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.samples {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.samples {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelfTestData {
        SelfTestData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SelfTestData_Sample>>(
                "samples",
                |m: &SelfTestData| { &m.samples },
                |m: &mut SelfTestData| { &mut m.samples },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SelfTestData>(
                "SelfTestData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SelfTestData {
        static instance: ::protobuf::rt::LazyV2<SelfTestData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SelfTestData::new)
    }
}

impl ::protobuf::Clear for SelfTestData {
    fn clear(&mut self) {
        self.samples.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SelfTestData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelfTestData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SelfTestData_Sample {
    // message fields
    input: ::protobuf::SingularField<::std::string::String>,
    expected: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SelfTestData_Sample {
    fn default() -> &'a SelfTestData_Sample {
        <SelfTestData_Sample as ::protobuf::Message>::default_instance()
    }
}

impl SelfTestData_Sample {
    pub fn new() -> SelfTestData_Sample {
        ::std::default::Default::default()
    }

    // optional string input = 1;


    pub fn get_input(&self) -> &str {
        match self.input.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    pub fn has_input(&self) -> bool {
        self.input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: ::std::string::String) {
        self.input = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input(&mut self) -> &mut ::std::string::String {
        if self.input.is_none() {
            self.input.set_default();
        }
        self.input.as_mut().unwrap()
    }

    // Take field
    pub fn take_input(&mut self) -> ::std::string::String {
        self.input.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string expected = 2;


    pub fn get_expected(&self) -> &str {
        match self.expected.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_expected(&mut self) {
        self.expected.clear();
    }

    pub fn has_expected(&self) -> bool {
        self.expected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expected(&mut self, v: ::std::string::String) {
        self.expected = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expected(&mut self) -> &mut ::std::string::String {
        if self.expected.is_none() {
            self.expected.set_default();
        }
        self.expected.as_mut().unwrap()
    }

    // Take field
    pub fn take_expected(&mut self) -> ::std::string::String {
        self.expected.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for SelfTestData_Sample {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.input)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.expected)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.input.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.expected.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.input.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.expected.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelfTestData_Sample {
        SelfTestData_Sample::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input",
                |m: &SelfTestData_Sample| { &m.input },
                |m: &mut SelfTestData_Sample| { &mut m.input },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "expected",
                |m: &SelfTestData_Sample| { &m.expected },
                |m: &mut SelfTestData_Sample| { &mut m.expected },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SelfTestData_Sample>(
                "SelfTestData.Sample",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SelfTestData_Sample {
        static instance: ::protobuf::rt::LazyV2<SelfTestData_Sample> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SelfTestData_Sample::new)
    }
}

impl ::protobuf::Clear for SelfTestData_Sample {
    fn clear(&mut self) {
        self.input.clear();
        self.expected.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SelfTestData_Sample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelfTestData_Sample {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModelProto {
    // message fields
    pub pieces: ::protobuf::RepeatedField<ModelProto_SentencePiece>,
    pub trainer_spec: ::protobuf::SingularPtrField<TrainerSpec>,
    pub normalizer_spec: ::protobuf::SingularPtrField<NormalizerSpec>,
    pub self_test_data: ::protobuf::SingularPtrField<SelfTestData>,
    pub denormalizer_spec: ::protobuf::SingularPtrField<NormalizerSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModelProto {
    fn default() -> &'a ModelProto {
        <ModelProto as ::protobuf::Message>::default_instance()
    }
}

impl ModelProto {
    pub fn new() -> ModelProto {
        ::std::default::Default::default()
    }

    // repeated .sentencepiece.ModelProto.SentencePiece pieces = 1;


    pub fn get_pieces(&self) -> &[ModelProto_SentencePiece] {
        &self.pieces
    }
    pub fn clear_pieces(&mut self) {
        self.pieces.clear();
    }

    // Param is passed by value, moved
    pub fn set_pieces(&mut self, v: ::protobuf::RepeatedField<ModelProto_SentencePiece>) {
        self.pieces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pieces(&mut self) -> &mut ::protobuf::RepeatedField<ModelProto_SentencePiece> {
        &mut self.pieces
    }

    // Take field
    pub fn take_pieces(&mut self) -> ::protobuf::RepeatedField<ModelProto_SentencePiece> {
        ::std::mem::replace(&mut self.pieces, ::protobuf::RepeatedField::new())
    }

    // optional .sentencepiece.TrainerSpec trainer_spec = 2;


    pub fn get_trainer_spec(&self) -> &TrainerSpec {
        self.trainer_spec.as_ref().unwrap_or_else(|| <TrainerSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trainer_spec(&mut self) {
        self.trainer_spec.clear();
    }

    pub fn has_trainer_spec(&self) -> bool {
        self.trainer_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trainer_spec(&mut self, v: TrainerSpec) {
        self.trainer_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trainer_spec(&mut self) -> &mut TrainerSpec {
        if self.trainer_spec.is_none() {
            self.trainer_spec.set_default();
        }
        self.trainer_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_trainer_spec(&mut self) -> TrainerSpec {
        self.trainer_spec.take().unwrap_or_else(|| TrainerSpec::new())
    }

    // optional .sentencepiece.NormalizerSpec normalizer_spec = 3;


    pub fn get_normalizer_spec(&self) -> &NormalizerSpec {
        self.normalizer_spec.as_ref().unwrap_or_else(|| <NormalizerSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_normalizer_spec(&mut self) {
        self.normalizer_spec.clear();
    }

    pub fn has_normalizer_spec(&self) -> bool {
        self.normalizer_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normalizer_spec(&mut self, v: NormalizerSpec) {
        self.normalizer_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_normalizer_spec(&mut self) -> &mut NormalizerSpec {
        if self.normalizer_spec.is_none() {
            self.normalizer_spec.set_default();
        }
        self.normalizer_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_normalizer_spec(&mut self) -> NormalizerSpec {
        self.normalizer_spec.take().unwrap_or_else(|| NormalizerSpec::new())
    }

    // optional .sentencepiece.SelfTestData self_test_data = 4;


    pub fn get_self_test_data(&self) -> &SelfTestData {
        self.self_test_data.as_ref().unwrap_or_else(|| <SelfTestData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_self_test_data(&mut self) {
        self.self_test_data.clear();
    }

    pub fn has_self_test_data(&self) -> bool {
        self.self_test_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_self_test_data(&mut self, v: SelfTestData) {
        self.self_test_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_self_test_data(&mut self) -> &mut SelfTestData {
        if self.self_test_data.is_none() {
            self.self_test_data.set_default();
        }
        self.self_test_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_self_test_data(&mut self) -> SelfTestData {
        self.self_test_data.take().unwrap_or_else(|| SelfTestData::new())
    }

    // optional .sentencepiece.NormalizerSpec denormalizer_spec = 5;


    pub fn get_denormalizer_spec(&self) -> &NormalizerSpec {
        self.denormalizer_spec.as_ref().unwrap_or_else(|| <NormalizerSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_denormalizer_spec(&mut self) {
        self.denormalizer_spec.clear();
    }

    pub fn has_denormalizer_spec(&self) -> bool {
        self.denormalizer_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denormalizer_spec(&mut self, v: NormalizerSpec) {
        self.denormalizer_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denormalizer_spec(&mut self) -> &mut NormalizerSpec {
        if self.denormalizer_spec.is_none() {
            self.denormalizer_spec.set_default();
        }
        self.denormalizer_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_denormalizer_spec(&mut self) -> NormalizerSpec {
        self.denormalizer_spec.take().unwrap_or_else(|| NormalizerSpec::new())
    }
}

impl ::protobuf::Message for ModelProto {
    fn is_initialized(&self) -> bool {
        for v in &self.pieces {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trainer_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.normalizer_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.self_test_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.denormalizer_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pieces)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trainer_spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.normalizer_spec)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.self_test_data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.denormalizer_spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.pieces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.trainer_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.normalizer_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.self_test_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.denormalizer_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.pieces {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.trainer_spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.normalizer_spec.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.self_test_data.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.denormalizer_spec.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelProto {
        ModelProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModelProto_SentencePiece>>(
                "pieces",
                |m: &ModelProto| { &m.pieces },
                |m: &mut ModelProto| { &mut m.pieces },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TrainerSpec>>(
                "trainer_spec",
                |m: &ModelProto| { &m.trainer_spec },
                |m: &mut ModelProto| { &mut m.trainer_spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NormalizerSpec>>(
                "normalizer_spec",
                |m: &ModelProto| { &m.normalizer_spec },
                |m: &mut ModelProto| { &mut m.normalizer_spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SelfTestData>>(
                "self_test_data",
                |m: &ModelProto| { &m.self_test_data },
                |m: &mut ModelProto| { &mut m.self_test_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NormalizerSpec>>(
                "denormalizer_spec",
                |m: &ModelProto| { &m.denormalizer_spec },
                |m: &mut ModelProto| { &mut m.denormalizer_spec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModelProto>(
                "ModelProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModelProto {
        static instance: ::protobuf::rt::LazyV2<ModelProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModelProto::new)
    }
}

impl ::protobuf::Clear for ModelProto {
    fn clear(&mut self) {
        self.pieces.clear();
        self.trainer_spec.clear();
        self.normalizer_spec.clear();
        self.self_test_data.clear();
        self.denormalizer_spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModelProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModelProto_SentencePiece {
    // message fields
    piece: ::protobuf::SingularField<::std::string::String>,
    score: ::std::option::Option<f32>,
    field_type: ::std::option::Option<ModelProto_SentencePiece_Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModelProto_SentencePiece {
    fn default() -> &'a ModelProto_SentencePiece {
        <ModelProto_SentencePiece as ::protobuf::Message>::default_instance()
    }
}

impl ModelProto_SentencePiece {
    pub fn new() -> ModelProto_SentencePiece {
        ::std::default::Default::default()
    }

    // optional string piece = 1;


    pub fn get_piece(&self) -> &str {
        match self.piece.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_piece(&mut self) {
        self.piece.clear();
    }

    pub fn has_piece(&self) -> bool {
        self.piece.is_some()
    }

    // Param is passed by value, moved
    pub fn set_piece(&mut self, v: ::std::string::String) {
        self.piece = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_piece(&mut self) -> &mut ::std::string::String {
        if self.piece.is_none() {
            self.piece.set_default();
        }
        self.piece.as_mut().unwrap()
    }

    // Take field
    pub fn take_piece(&mut self) -> ::std::string::String {
        self.piece.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float score = 2;


    pub fn get_score(&self) -> f32 {
        self.score.unwrap_or(0.)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional .sentencepiece.ModelProto.SentencePiece.Type type = 3;


    pub fn get_field_type(&self) -> ModelProto_SentencePiece_Type {
        self.field_type.unwrap_or(ModelProto_SentencePiece_Type::NORMAL)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ModelProto_SentencePiece_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ModelProto_SentencePiece {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.piece)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.piece.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.score {
            my_size += 5;
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.piece.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.score {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelProto_SentencePiece {
        ModelProto_SentencePiece::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "piece",
                |m: &ModelProto_SentencePiece| { &m.piece },
                |m: &mut ModelProto_SentencePiece| { &mut m.piece },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "score",
                |m: &ModelProto_SentencePiece| { &m.score },
                |m: &mut ModelProto_SentencePiece| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ModelProto_SentencePiece_Type>>(
                "type",
                |m: &ModelProto_SentencePiece| { &m.field_type },
                |m: &mut ModelProto_SentencePiece| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModelProto_SentencePiece>(
                "ModelProto.SentencePiece",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModelProto_SentencePiece {
        static instance: ::protobuf::rt::LazyV2<ModelProto_SentencePiece> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModelProto_SentencePiece::new)
    }
}

impl ::protobuf::Clear for ModelProto_SentencePiece {
    fn clear(&mut self) {
        self.piece.clear();
        self.score = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModelProto_SentencePiece {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelProto_SentencePiece {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ModelProto_SentencePiece_Type {
    NORMAL = 1,
    UNKNOWN = 2,
    CONTROL = 3,
    USER_DEFINED = 4,
    BYTE = 6,
    UNUSED = 5,
}

impl ::protobuf::ProtobufEnum for ModelProto_SentencePiece_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ModelProto_SentencePiece_Type> {
        match value {
            1 => ::std::option::Option::Some(ModelProto_SentencePiece_Type::NORMAL),
            2 => ::std::option::Option::Some(ModelProto_SentencePiece_Type::UNKNOWN),
            3 => ::std::option::Option::Some(ModelProto_SentencePiece_Type::CONTROL),
            4 => ::std::option::Option::Some(ModelProto_SentencePiece_Type::USER_DEFINED),
            6 => ::std::option::Option::Some(ModelProto_SentencePiece_Type::BYTE),
            5 => ::std::option::Option::Some(ModelProto_SentencePiece_Type::UNUSED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ModelProto_SentencePiece_Type] = &[
            ModelProto_SentencePiece_Type::NORMAL,
            ModelProto_SentencePiece_Type::UNKNOWN,
            ModelProto_SentencePiece_Type::CONTROL,
            ModelProto_SentencePiece_Type::USER_DEFINED,
            ModelProto_SentencePiece_Type::BYTE,
            ModelProto_SentencePiece_Type::UNUSED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ModelProto_SentencePiece_Type>("ModelProto.SentencePiece.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ModelProto_SentencePiece_Type {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ModelProto_SentencePiece_Type {
    fn default() -> Self {
        ModelProto_SentencePiece_Type::NORMAL
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelProto_SentencePiece_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19sentencepiece_model.proto\x12\rsentencepiece\"\xdb\x0f\n\x0bTraine\
    rSpec\x12\x16\n\x05input\x18\x01\x20\x03(\tR\x05inputB\0\x12#\n\x0cinput\
    _format\x18\x07\x20\x01(\tR\x0binputFormatB\0\x12#\n\x0cmodel_prefix\x18\
    \x02\x20\x01(\tR\x0bmodelPrefixB\0\x12N\n\nmodel_type\x18\x03\x20\x01(\
    \x0e2$.sentencepiece.TrainerSpec.ModelType:\x07UNIGRAMR\tmodelTypeB\0\
    \x12%\n\nvocab_size\x18\x04\x20\x01(\x05:\x048000R\tvocabSizeB\0\x12)\n\
    \x0faccept_language\x18\x05\x20\x03(\tR\x0eacceptLanguageB\0\x126\n\x15s\
    elf_test_sample_size\x18\x06\x20\x01(\x05:\x010R\x12selfTestSampleSizeB\
    \0\x127\n\x12character_coverage\x18\n\x20\x01(\x02:\x060.9995R\x11charac\
    terCoverageB\0\x123\n\x13input_sentence_size\x18\x0b\x20\x01(\x04:\x010R\
    \x11inputSentenceSizeB\0\x12<\n\x16shuffle_input_sentence\x18\x13\x20\
    \x01(\x08:\x04trueR\x14shuffleInputSentenceB\0\x124\n\x14mining_sentence\
    _size\x18\x0c\x20\x01(\x05R\x12miningSentenceSizeB\x02\x18\x01\x128\n\
    \x16training_sentence_size\x18\r\x20\x01(\x05R\x14trainingSentenceSizeB\
    \x02\x18\x01\x12A\n\x17seed_sentencepiece_size\x18\x0e\x20\x01(\x05:\x07\
    1000000R\x15seedSentencepieceSizeB\0\x121\n\x10shrinking_factor\x18\x0f\
    \x20\x01(\x02:\x040.75R\x0fshrinkingFactorB\0\x126\n\x13max_sentence_len\
    gth\x18\x12\x20\x01(\x05:\x044192R\x11maxSentenceLengthB\0\x12%\n\x0bnum\
    _threads\x18\x10\x20\x01(\x05:\x0216R\nnumThreadsB\0\x121\n\x12num_sub_i\
    terations\x18\x11\x20\x01(\x05:\x012R\x10numSubIterationsB\0\x12>\n\x18m\
    ax_sentencepiece_length\x18\x14\x20\x01(\x05:\x0216R\x16maxSentencepiece\
    LengthB\0\x12=\n\x17split_by_unicode_script\x18\x15\x20\x01(\x08:\x04tru\
    eR\x14splitByUnicodeScriptB\0\x12.\n\x0fsplit_by_number\x18\x17\x20\x01(\
    \x08:\x04trueR\rsplitByNumberB\0\x126\n\x13split_by_whitespace\x18\x16\
    \x20\x01(\x08:\x04trueR\x11splitByWhitespaceB\0\x12D\n\x1atreat_whitespa\
    ce_as_suffix\x18\x18\x20\x01(\x08:\x05falseR\x17treatWhitespaceAsSuffixB\
    \0\x12*\n\x0csplit_digits\x18\x19\x20\x01(\x08:\x05falseR\x0bsplitDigits\
    B\0\x12)\n\x0fcontrol_symbols\x18\x1e\x20\x03(\tR\x0econtrolSymbolsB\0\
    \x122\n\x14user_defined_symbols\x18\x1f\x20\x03(\tR\x12userDefinedSymbol\
    sB\0\x12'\n\x0erequired_chars\x18$\x20\x01(\tR\rrequiredCharsB\0\x12,\n\
    \rbyte_fallback\x18#\x20\x01(\x08:\x05falseR\x0cbyteFallbackB\0\x12I\n\
    \x1dvocabulary_output_piece_score\x18\x20\x20\x01(\x08:\x04trueR\x1avoca\
    bularyOutputPieceScoreB\0\x120\n\x10hard_vocab_limit\x18!\x20\x01(\x08:\
    \x04trueR\x0ehardVocabLimitB\0\x12+\n\ruse_all_vocab\x18\"\x20\x01(\x08:\
    \x05falseR\x0buseAllVocabB\0\x12\x1a\n\x06unk_id\x18(\x20\x01(\x05:\x010\
    R\x05unkIdB\0\x12\x1a\n\x06bos_id\x18)\x20\x01(\x05:\x011R\x05bosIdB\0\
    \x12\x1a\n\x06eos_id\x18*\x20\x01(\x05:\x012R\x05eosIdB\0\x12\x1b\n\x06p\
    ad_id\x18+\x20\x01(\x05:\x02-1R\x05padIdB\0\x12$\n\tunk_piece\x18-\x20\
    \x01(\t:\x05<unk>R\x08unkPieceB\0\x12\"\n\tbos_piece\x18.\x20\x01(\t:\
    \x03<s>R\x08bosPieceB\0\x12#\n\teos_piece\x18/\x20\x01(\t:\x04</s>R\x08e\
    osPieceB\0\x12$\n\tpad_piece\x180\x20\x01(\t:\x05<pad>R\x08padPieceB\0\
    \x12(\n\x0bunk_surface\x18,\x20\x01(\t:\x05\x20\xe2\x81\x87\x20R\nunkSur\
    faceB\0\x12H\n\x1ctrain_extremely_large_corpus\x181\x20\x01(\x08:\x05fal\
    seR\x19trainExtremelyLargeCorpusB\0\"7\n\tModelType\x12\x0b\n\x07UNIGRAM\
    \x10\x01\x12\x07\n\x03BPE\x10\x02\x12\x08\n\x04WORD\x10\x03\x12\x08\n\
    \x04CHAR\x10\x04\x1a\0:\0\"\xc0\x02\n\x0eNormalizerSpec\x12\x14\n\x04nam\
    e\x18\x01\x20\x01(\tR\x04nameB\0\x123\n\x14precompiled_charsmap\x18\x02\
    \x20\x01(\x0cR\x13precompiledCharsmapB\0\x120\n\x10add_dummy_prefix\x18\
    \x03\x20\x01(\x08:\x04trueR\x0eaddDummyPrefixB\0\x12@\n\x18remove_extra_\
    whitespaces\x18\x04\x20\x01(\x08:\x04trueR\x16removeExtraWhitespacesB\0\
    \x125\n\x12escape_whitespaces\x18\x05\x20\x01(\x08:\x04trueR\x11escapeWh\
    itespacesB\0\x126\n\x16normalization_rule_tsv\x18\x06\x20\x01(\tR\x14nor\
    malizationRuleTsvB\0:\0\"\x92\x01\n\x0cSelfTestData\x12>\n\x07samples\
    \x18\x01\x20\x03(\x0b2\".sentencepiece.SelfTestData.SampleR\x07samplesB\
    \0\x1a@\n\x06Sample\x12\x16\n\x05input\x18\x01\x20\x01(\tR\x05inputB\0\
    \x12\x1c\n\x08expected\x18\x02\x20\x01(\tR\x08expectedB\0:\0:\0\"\xd7\
    \x04\n\nModelProto\x12A\n\x06pieces\x18\x01\x20\x03(\x0b2'.sentencepiece\
    .ModelProto.SentencePieceR\x06piecesB\0\x12?\n\x0ctrainer_spec\x18\x02\
    \x20\x01(\x0b2\x1a.sentencepiece.TrainerSpecR\x0btrainerSpecB\0\x12H\n\
    \x0fnormalizer_spec\x18\x03\x20\x01(\x0b2\x1d.sentencepiece.NormalizerSp\
    ecR\x0enormalizerSpecB\0\x12C\n\x0eself_test_data\x18\x04\x20\x01(\x0b2\
    \x1b.sentencepiece.SelfTestDataR\x0cselfTestDataB\0\x12L\n\x11denormaliz\
    er_spec\x18\x05\x20\x01(\x0b2\x1d.sentencepiece.NormalizerSpecR\x10denor\
    malizerSpecB\0\x1a\xe5\x01\n\rSentencePiece\x12\x16\n\x05piece\x18\x01\
    \x20\x01(\tR\x05pieceB\0\x12\x16\n\x05score\x18\x02\x20\x01(\x02R\x05sco\
    reB\0\x12J\n\x04type\x18\x03\x20\x01(\x0e2,.sentencepiece.ModelProto.Sen\
    tencePiece.Type:\x06NORMALR\x04typeB\0\"V\n\x04Type\x12\n\n\x06NORMAL\
    \x10\x01\x12\x0b\n\x07UNKNOWN\x10\x02\x12\x0b\n\x07CONTROL\x10\x03\x12\
    \x10\n\x0cUSER_DEFINED\x10\x04\x12\x08\n\x04BYTE\x10\x06\x12\n\n\x06UNUS\
    ED\x10\x05\x1a\0:\0:\0B\0b\x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
